#'@title Calculates power given a run matrix
#'
#'@description Evaluates design given a run matrix and returns
#'a data frame of parameter and effect powers. Functions with designs
#'consisting of both continuous and catagorical factors. Currently only works
#'with linear, non-interacting models.
#'
#'@param RunMatrix The run matrix being evaluated. If the design was not generated by gen_design,
#'the model matrix will be generated using the model provided.
#'@param model The model used in evaluating the design. It can be a subset of the model used to
#'generate the design.
#'@param alpha The specified type-I error.
#'@param anticoef The anticipated coefficients for calculating the power. If missing, coefficients will be
#'automatically generated.
#'@param delta Default 2. This specifies the difference between the high and low levels.
#'Anticipated coefficients will be half of this number.
#'@param conservative Default FALSE. Specifies whether default method for generating
#'anticipated coefficents should be conservative or not. TRUE will give the most conservative
#'estimate of power by setting all but one level in a catagorical factor's anticipated coefficients
#'to zero.
#'@return A data frame with the parameters of the model, the type of power analysis, and the power.
#'@import AlgDesign
#'@export
#'@examples #generating a simple 2x3 factorial using AlgDesign's gen.factorial function
#'#to feed into our optimal design generation and and generating a 11-run design.
#'factorial <- AlgDesign::gen.factorial(levels = 2, nVars = 3, varNames = c("A", "B", "C"))
#'optdesign = gen_design(factorial=factorial, model= ~A+B+C,trials=11,optimality="D",repeats=100)
#'
#'#Now evaluating that design (with default anticipated coefficients and a delta of 2):
#'eval_design(RunMatrix=optdesign, model= ~A+B+C, alpha=0.2)
#'
#'#Evaluating a subset of the design (changing the power due to a different number of
#'#degrees of freedom)
#'eval_design(RunMatrix=optdesign, model= ~A+C, alpha=0.2)
#'
#'#Halving the signal-to-noise ratio by setting a different delta (default is 2):
#'eval_design(RunMatrix=optdesign, model= ~A+B+C, alpha=0.2,delta=1)
#'
#'#With 3+ level catagorical factors, the choice of anticipated coefficients directly changes the
#'#final power calculation. For the most conservative power calculation, that involves
#'#setting all anticipated coefficients in a factor to zero except for one. We can specify this
#'#option with the "conservative" argument.
#'
#'factorialcoffee = expand.grid(cost=c(1,2),
#'                              type=as.factor(c("Kona","Colombian","Ethiopian","Sumatra")),
#'                              size=as.factor(c("Short","Grande","Venti")))
#'
#'designcoffee = gen_design(factorialcoffee,~cost + size + type,trials=29,optimality="D",repeats=100)
#'
#'#Evaluate the design, with default anticipated coefficients (conservative is FALSE by default).
#'eval_design(designcoffee,model=~cost+size+type, alpha=0.05)
#'
#'#Evaluate the design, with conservative anticipated coefficients:
#'eval_design(designcoffee,model=~cost+size+type, alpha=0.05,conservative=TRUE)
#'
#'#which is the same as the following, but now explicitly entering the coefficients:
#'eval_design(designcoffee,model=~cost+size+type, alpha=0.05,anticoef=c(1,1,1,0,0,1,0))
#'
#'#If the first level in a factor is not the one that you want to set to one
#'#in the conservative calculation, enter the anticipated coefficients in manually.
#'eval_design(designcoffee,model=~cost+size+type, alpha=0.05,anticoef=c(1,1,0,0,1,0,1))

eval_design = function(RunMatrix, model, alpha, anticoef, delta=2, conservative=FALSE) {
  if(is.null(attr(RunMatrix,"modelmatrix"))) {
    contrastslist = list()
    for(x in names(RunMatrix[sapply(RunMatrix,class) == "factor"])) {
      contrastslist[x] = "contr.sum"
    }
    if(length(contrastslist) == 0) {
      attr(RunMatrix,"modelmatrix") = model.matrix(model.matrix(model,RunMatrix))
    } else {
      attr(RunMatrix,"modelmatrix") = model.matrix(model.matrix(model,RunMatrix,contrasts.arg=contrastslist))
    }
  }

  RunMatrix = reducemodelmatrix(RunMatrix,model)

  if(missing(anticoef)) {
    anticoef = gen_anticoef(RunMatrix,conservative=conservative)
  }
  if(length(anticoef) != dim(attr(RunMatrix,"modelmatrix"))[2] && any(sapply(RunMatrix,class)=="factor")) {
    stop("Wrong number of anticipated coefficients")
  }
  if(length(anticoef) != dim(attr(RunMatrix,"modelmatrix"))[2] && !any(sapply(RunMatrix,class)=="factor")) {
    anticoef = rep(1,dim(attr(RunMatrix,"modelmatrix"))[2])
  }

  #This returns if everything is continuous (no catagorical)
  if (!any(table(attr(attr(RunMatrix,"modelmatrix"),"assign")[-1])!=1)) {
    effectresults = parameterpower(RunMatrix,anticoef*delta/2,alpha)
    typevector = rep("effect.power",length(effectresults))
    namevector = colnames(attr(RunMatrix,"modelmatrix"))
    return(data.frame(parameters = namevector, type = typevector, power = effectresults))
  } else {
    levelvector = sapply(lapply(RunMatrix,unique),length)

    #generating number of catagorical factors

    catornot = rep(0,length(sapply(RunMatrix,class)))
    catornot[sapply(RunMatrix,class) == "factor"] = 1
    priorcat = priorlevels(catornot)

    effectresults = effectpower(RunMatrix,levelvector,anticoef*delta/2,alpha,priorcat)
    parameterresults = parameterpower(RunMatrix,anticoef*delta/2,alpha)

    typevector = c(rep("effect.power",length(effectresults)),rep("parameter.power",length(parameterresults)))
    powervector = c(effectresults,parameterresults)
    effectnamevector = c("(intercept)",names(sapply(lapply(RunMatrix,unique),length)))
    parameternamevector = colnames(attr(RunMatrix,"modelmatrix"))
    namevector = c(effectnamevector,parameternamevector)

    if(length(namevector) != length(typevector)) {
      warning("Number of names does not equal number of power calculations")
    }
    return(data.frame(parameters = namevector, type = typevector, power = powervector))
  }
}
