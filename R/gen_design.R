#'@title Generates the optimal run matrix from full factorial, model, optimality criterion,
#'and desired number of runs.
#'
#'@description Creates design given a model and desired number of runs, returning the model matrix. Currently
#'Used with eval_design/eval_design_mc to produce power estimations for designs.
#'
#'@param factorial A full factorial test matrix generated for the factors in the model. If
#'the factor is continuous, it should be type numeric. If the factor is categorical, it should be
#'set as a factor.
#'@param model The model used to generate the test design.
#'@param trials The number of runs in the design.
#'@param wholeblock A data frame specifying the blocking factors.
#'@param blocksize The number of runs in each block.
#'@param optimality The optimality criterion (e.g. "D")
#'@param repeats The number of times to repeat the search for the best optimal condition. If missing, this defaults to 100.
#'@param ... Any additional arguments to be input into AlgDesign's optFederov during design generation.
#'@return The model matrix for the design, to be passed to eval_design. The model matrix
#'has various attributes (accessible with the attr function) that aid evaluation.
#'@import AlgDesign
#'@export
#'@examples #Generate the basic factorial design used in generating the optimal design with
#'#expand.grid.
#'#Generating a basic 2 factor design:
#'basicdesign = expand.grid(x1=c(-1,1),x2=c(-1,1))
#'
#'#We can also generate the factorial using AlgDesign's gen.factorial function.
#'design_gf = AlgDesign::gen.factorial(levels=c(2,2),nVars=2,varNames=c("x1","x2"))
#'
#'#This factorial design is used as an input in the optimal design generation for a
#'#D-optimal design with 11 runs.
#'design = gen_design(factorial=basicdesign,model=~x1+x2,trials=11,optimality="D",repeats=100)
#'
#'#Here we add categorical factors, specified by using "as.factor" in expand.grid:
#'fulldesign = expand.grid(a=c(-1,1),b=as.factor(c("A","B")),c=as.factor(c("High","Med","Low")))
#'
#'#This factorial design is used as an input in the optimal design generation.
#'design2 = gen_design(factorial=fulldesign,model=~a+b+c,trials=19,optimality="D",repeats=100)
#'
#'#We can also decrease the number of repeats searches to increase speed (at the expense of
#'#possibly not having the best optimal design)
#'design2 = gen_design(factorial=fulldesign,model=~a+b+c,trials=19,optimality="D",repeats=5)
#'
#'#You can also use a higher order model when generating the design:
#'design2 = gen_design(factorial=fulldesign,model=~a+b+c+a*b*c,trials=19,optimality="D")
#'
#'#We can specify different methods of calculating contrasts for each factor in a list.
#'design2 = gen_design(factorial=fulldesign,model=~a+b+c,trials=19,optimality="D",
#'                    repeats=100,contrastslist=list(b="contr.sum",c="contr.treatment"))
#'
#'#Blocked designs can also be generated by specifying a data frame with the blocking levels
#'#as well as the number of runs per block.
#'
#'#6 blocks
#'blocking = data.frame(Block = as.factor(c(1,2,3,4,5,6)))
#'
#'#5 runs per block
#'designblocked = gen_design(factorial=fulldesign,model=~a+b+c+Block,trials=30,
#'                           wholeblock=blocking, blocksize=5)
#'
#'#A split plot design can also be generated by first generating a d-optimal blocking design
#'#and then using that as the input for the blocks.
#'
#'blockfactors = data.frame(Range = as.factor(c("Close","Mid","Far")))
#'blocks = gen_design(factorial = blockfactors, model=~Range, trials=11)
#'
#'#Now we can use the d-optimal blocked design as an input to our full design
#'
#'designsplitplot = gen_design(factorial=fulldesign,model=~a+b+c+Range,trials=33,
#'                           wholeblock=blocks, blocksize=3)
#'
#'#The optimality numbers can be accessed as an attribute of the run matrix.
#'#See AlgDesign::optFederov documentation for more information.
#'attr(design2,"D") #The kth root of the generalized variance.
#'attr(design2,"A") #The average coefficient variance.
#'attr(design2,"Ge") #The minimax normalized variance.
#'attr(design2,"Dea") #A lower bound on D efficiency for approximate theory designs.
#'
#'#The I optimality number is not calculated unless the design is generated as I optimal:
#'design3 = gen_design(factorial=fulldesign,model=~a+b+c,trials=19,optimality="I",repeats=100)
#'attr(design3,"I") #The average prediction variance over X
#'
#'#Evaluating the design for power can be done with eval_design, eval_design_mc (Monte Carlo)
#'#and eval_design_survival_mc (Monte Carlo survival analysis)


gen_design = function(factorial, model, trials, wholeblock=NULL, blocksize=NULL,
                       optimality="D",repeats=100, ...) {
  blocking = FALSE

  if(!missing(wholeblock)) {
    blocking = TRUE
    if(missing(blocksize)) {
      stop("Need blocksize as input for blocked design")
    }
  }
  if(ceiling(trials/blocksize) != nrow(wholeblock) && length(blocksize) == 1) {
    min = nrow(wholeblock)*(blocksize)-blocksize+1
    max = nrow(wholeblock)*(blocksize)
    stop(paste("For given blocking factor(s) and block size, minimum number of runs for this design is:",
                  min, "and the maximum is:", max))
  }

  if(length(blocksize) > 1 && length(blocksize) != nrow(wholeblock)) {
    stop("Custom blocksize vector must be equal in length to number of wholeblock runs")
  }

  #replicates the pool of design points because AlgDesign samples without replacement
  factorial = do.call("rbind", replicate(trials, factorial, simplify = FALSE))

  if(!blocking) {
    dfmodelmatrix = AlgDesign::optFederov(model,data=factorial,nTrials=trials,
                                        criterion = optimality,nRepeats = repeats, ...)
  } else {
    dfmodelmatrix = AlgDesign::optBlock(frml=model,withinData=factorial,
                                        blocksizes=calcblocksizes(trials,blocksize),
                                        wholeBlockData=wholeblock,criterion = optimality,
                                        nRepeats = repeats, ...)
  }

  mm = dfmodelmatrix[["design"]]
  attr(mm,"D") = dfmodelmatrix[["D"]]
  attr(mm,"A") = dfmodelmatrix[["A"]]
  attr(mm,"Ge") = dfmodelmatrix[["Ge"]]
  attr(mm,"Dea") = dfmodelmatrix[["Dea"]]

  return(mm)
}
