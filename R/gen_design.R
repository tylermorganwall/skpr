#'@title Generates the optimal run matrix from full factorial, model, optimality criterion,
#'and desired number of runs.
#'
#'@description Creates design given a model and desired number of runs, returning the model matrix. Currently
#'Used with eval_design/eval_design_mc to produce power estimations for designs.
#'
#'@param factorial A full factorial test matrix generated for the factors in the model. If
#'the factor is continuous, it should be type numeric. If the factor is categorical, it should be
#'set as a factor.
#'@param model The model used to generate the test design.
#'@param trials The number of runs in the design.
#'@param wholeblock A data frame specifying the blocking factors.
#'@param blocksize The number of runs in each block.
#'@param optimality The optimality criterion (e.g. "D")
#'@param repeats The number of times to repeat the search for the best optimal condition. If missing, this defaults to 100.
#'@param ... Any additional arguments to be input into AlgDesign's optFederov during design generation.
#'@return The model matrix for the design, to be passed to eval_design. The model matrix
#'has various attributes (accessible with the attr function) that aid evaluation.
#'@import AlgDesign
#'@export
#'@examples #Generate the basic factorial design used in generating the optimal design with
#'#expand.grid.
#'#Generating a basic 2 factor design:
#'basicdesign = expand.grid(x1=c(-1,1),x2=c(-1,1))
#'
#'#This factorial design is used as an input in the optimal design generation for a
#'#D-optimal design with 11 runs.
#'design = gen_design(factorial=basicdesign,model=~x1+x2,trials=11)
#'
#'#We can also use the dot operator to automatically use all of the terms in the model:
#'design = gen_design(factorial=basicdesign,model=~.,trials=11)
#'
#'#Here we add categorical factors, specified by using "as.factor" in expand.grid:
#'categoricaldesign = expand.grid(a=c(-1,1),b=as.factor(c("A","B")),c=as.factor(c("High","Med","Low")))
#'
#'#This factorial design is used as an input in the optimal design generation.
#'design2 = gen_design(factorial=categoricaldesign,model=~a+b+c,trials=19)
#'
#'#We can also increase the number of times the algorithm repeats the search to increase the probability
#'#that the globally optimal design was found.
#'design2 = gen_design(factorial=fulldesign,model=~a+b+c,trials=19,repeats=100)
#'
#'#You can also use a higher order model when generating the design:
#'design2 = gen_design(factorial=fulldesign,model=~a+b+c+a*b*c,trials=19)
#'
#'#To evaluate a response surface design, include center points in the candidate set and do not include
#'#quadratic effects with categorical factors.
#'
#'designquad = expand.grid(a=c(1,0,-1),b=c(-1,0,1),c=c("A","B","C"))
#'
#'gen_design(designquad, ~a+b+I(a^2)+I(b^2)+a*b*c, 20)
#'
#'The optimality criterion can also be changed:
#'gen_design(designquad, ~a+b+I(a^2)+I(b^2)+a*b*c, 20,optimality="I")
#'gen_design(designquad, ~a+b+I(a^2)+I(b^2)+a*b*c, 20,optimality="A")
#'
#'#A split-plot design can be generated by first generating an optimal blocking design using the
#'#hard-to-change factors and then using that as the input for the split-plots design.
#'#This generates an optimal subplot design that accounts for the existing split-plot settings.
#'#See the accompannying paper "___________" for details of the implementation.
#'
#'hardtochangefactor = expand.grid(Altitude=c(-1,1))
#'hardtochangedesign = gen_design(factorial = hardtochangefactor, model=~Altitude, trials=11)
#'
#'#Now we can use the D-optimal blocked design as an input to our full design.
#'
#'easytochangefactors = expand.grid(Range=as.factor(c("Close","Medium","Far")),Power=c(1,-1))
#'
#'#Here, we specify the easy to change factors for the factorial design, and input the hard-to-change design
#'#along with a vector listing the number of repetitions for each block run for the blocked design. There needs
#'#to be a size entry for every block and the number of runs specified in the trials argument needs to equal the
#'#sum of all of the block sizes.
#'
#'#Since we have 11 runs in our hard-to-change design, we need a vector specifying the size of each 11 runs. Here
#'#we specify the blocks be three runs each (meaning the final design will be 33 runs):
#'
#'splitplotblocksize = rep(3,11)
#'
#'#Putting this all together:
#'designsplitplot = gen_design(easytochangefactors, ~Range+Power, trials=33, htc=hardtochangedesign,
#'                             blocksizes = splitplotblocksize)
#'
#'#The split-plot structure is encoded into the row names, with a period demarcating the blocking level. This process
#'#can be repeated for arbitrary levels of blocking (i.e. a split-plot design can be entered in as the hard-to-change
#'#to produce a split-split-plot design, which can be passed as another hard-to-change design to produce a
#'#split-split-split plot design, etc).
#'
#'extremelyhtcfactors = expand.grid(Location=as.character(c("East","West")))
#'veryhtcfactors = expand.grid(Climate = as.factor(c("Dry","Wet","Arid")))
#'htcfactors = expand.grid(Vineyard = as.factor(c("A","B","C","D")))
#'etcfactors = expand.grid(Age = c(1,-1))
#'
#'gen_design(extremelyhtcfactors, ~Location, trials=6) -> temp
#'gen_design(veryhtcfactors, ~Climate, trials=12, splitplotdesign = temp, splitplotsizes=rep(2,6)) -> temp
#'gen_design(htcfactors, ~Vineyard,48,splitplotdesign = temp, splitplotsizes = rep(4,12)) -> temp
#'gen_design(etcfactors, ~Age, 192, splitplotdesign = temp, splitplotsizes = rep(4,48)) ->splitsplitsplitplotdesign
#'
#'
#'attr(design,"D") #The kth root of the generalized variance.
#'attr(design,"A") #The average coefficient variance.
#'attr(design,"I") #The average prediction variance across the design space
#'
#'#The correlation matrix can be accessed via the "correlation.matrix" attribute:
#'
#'correlation.matrix = attr(design2, "correlation.matrix")
#'
#'#A correlation color map can be produced with the following call to ggplot2 and reshape2
#'
#'\dontrun{melt(correlation.matrix) -> melted.correlation.matrix
#'ggplot(melted.correlation.matrix,aes(x=Var1,y=Var2,fill=value)) + geom_tile() +
#'  scale_fill_gradient2(mid="grey70",high="red", low="blue",midpoint=0.5) +
#'  theme(axis.text.x = element_text(angle = 90, hjust = 1,vjust=0.5))}
#'
#'#Evaluating the design for power can be done with eval_design, eval_design_mc (Monte Carlo)
#'#and eval_design_survival_mc (Monte Carlo survival analysis)
gen_design = function(factorial, model, trials, splitplotdesign = NULL, splitplotsizes = NULL,
                      optimality="D",repeats=10, contrast=contr.simplex, parallel=FALSE,  ...) {

  blocking=FALSE
  #generate blocked design with replicates
  if(!is.null(splitplotdesign)) {
    blocking = TRUE
    if(is.null(splitplotsizes)) {
      stop("If split plot design provided, user needs to input split plot sizes as well")
    }
    if(trials != sum(splitplotsizes)) {
      stop("Blocked replicates does not equal the number of trials input")
    }
    if(nrow(splitplotdesign) != length(splitplotsizes)) {
      stop("Need to specify a size for each row in the given split plot design")
    }
    alreadyBlocking = FALSE
    initialrownames = rownames(splitplotdesign)
    blocklist = strsplit(initialrownames,".",fixed=TRUE)

    if(any(lapply(blocklist,length) > 1)) {
      alreadyBlocking = TRUE
      initialrownames = rep(rownames(splitplotdesign),splitplotsizes)
      blocklist = strsplit(initialrownames,".",fixed=TRUE)
      existingBlockStructure = do.call(rbind,blocklist)
    }
    withinBlockRun = function(runs) {return(1:runs)}

    blockIndicators = rep(1:length(splitplotsizes),splitplotsizes)

    blockvars = colnames(splitplotdesign)
    blocks = list()
    for(i in 1:length(blockIndicators)) {
      blocks[[i]] = splitplotdesign[blockIndicators[i],]
    }

    blockRuns = c()
    for(i in 1:length(splitplotsizes)) {
      blockRuns = c(blockRuns,withinBlockRun(splitplotsizes[i]))
    }

    if(length(blocks[[1]]) > 1) {
      splitPlotReplicateDesign = as.data.frame(do.call(rbind, blocks))
    } else {
      splitPlotReplicateDesign = as.data.frame(unlist(blocks))
    }

    colnames(splitPlotReplicateDesign) = blockvars
    if(alreadyBlocking) {
      rownames(splitPlotReplicateDesign) = paste(initialrownames, blockRuns,sep=".")
    } else {
      rownames(splitPlotReplicateDesign) = paste(blockIndicators, blockRuns,sep=".")
    }
  }

  initialReplace = FALSE
  if(trials > nrow(factorial)) {
    initialReplace = TRUE
  }

  genOutput = list(repeats)

  contrastslist = list()
  for(x in names(factorial[lapply(factorial,class) == "factor"])) {
    contrastslist[[x]] = contrast
  }
  if(length(contrastslist) == 0) {
    factorialmm = model.matrix(model,factorial)
  } else {
    factorialmm = model.matrix(model,factorial,contrasts.arg=contrastslist)
  }

  if(!blocking) {
    factors = colnames(factorialmm)
    mm = gen_momentsmatrix(factors)
    if(!parallel) {
      for(i in 1:repeats) {
        randomIndices = sample(nrow(factorialmm), trials, replace = initialReplace)
        genOutput[[i]] = genOptimalDesign(initialdesign = factorialmm[randomIndices,], candidatelist=factorialmm,
                                        condition=optimality, momentsmatrix = mm, initialRows = randomIndices)
      }
    } else {
      cl <- parallel::makeCluster(parallel::detectCores())
      doParallel::registerDoParallel(cl, cores = parallel::detectCores())

      genOutput = foreach(i=1:repeats) %dopar% {
        randomIndices = sample(nrow(factorialmm), trials, replace = initialReplace)
        genOptimalDesign(initialdesign = factorialmm[randomIndices,], candidatelist=factorialmm,
                         condition=optimality, momentsmatrix = mm, initialRows = randomIndices)
      }
      parallel::stopCluster(cl)
    }
  } else {
    blockedContrastsList = list()
    for(x in names(splitPlotReplicateDesign[sapply(splitPlotReplicateDesign,class) == "factor"])) {
      blockedContrastsList[[x]] = contrast
    }
    if(length(blockedContrastsList) == 0) {
      blockedModelMatrix = model.matrix(~.,splitPlotReplicateDesign)
    } else {
      blockedModelMatrix = model.matrix(~.,splitPlotReplicateDesign,contrasts.arg=blockedContrastsList)
    }
    blockedFactors = c(colnames(blockedModelMatrix),colnames(factorialmm)[-1])
    blockedMM = gen_momentsmatrix(blockedFactors)
    if (!parallel) {
      for(i in 1:repeats) {
        randomIndices = sample(nrow(factorial), trials, replace = initialReplace)
        genOutput[[i]] = genBlockedOptimalDesign(initialdesign = factorialmm[randomIndices,],
                                                 candidatelist=factorialmm, blockeddesign = blockedModelMatrix,
                                                 condition=optimality, momentsmatrix = blockedMM, initialRows = randomIndices)
      }
    } else {
      cl <- parallel::makeCluster(parallel::detectCores())
      doParallel::registerDoParallel(cl, cores = parallel::detectCores())

      genOutput = foreach(i=1:repeats) %dopar% {
        randomIndices = sample(nrow(factorial), trials, replace = initialReplace)
        genBlockedOptimalDesign(initialdesign = factorialmm[randomIndices,],
                                candidatelist=factorialmm, blockeddesign = blockedModelMatrix,
                                condition=optimality, momentsmatrix = blockedMM, initialRows = randomIndices)
      }
      parallel::stopCluster(cl)
    }
  }

  designs = list(repeats)
  rowIndicies = list(repeats)
  criteria = list(repeats)

  for(i in 1:repeats) {
    designs[i] = genOutput[[i]]["modelmatrix"]
    rowIndicies[i] = genOutput[[i]]["indices"]
    criteria[i] = genOutput[[i]]["criterion"]
  }

  if(optimality == "D") {
    best = which.max(criteria)
    designmm = designs[[best]]
    rowindex = rowIndicies[[best]]
  }

  if(optimality == "A" || optimality == "I") {
    best = which.min(criteria)
    designmm = designs[[best]]
    rowindex = rowIndicies[[best]]
  }

  if(!blocking) {
    colnames(designmm) = factors
  } else {
    colnames(designmm) = blockedFactors
  }

  design = constructRunMatrix(rowIndices = rowindex, candidateList = factorial)

  if(blocking) {
    design = cbind(splitPlotReplicateDesign,design)
  }
  attr(design,"D-Efficiency") = 100*DOptimality(designmm)^(1/ncol(designmm))/nrow(designmm)
  attr(design,"A-Efficiency") = AOptimality(designmm)
  if(!blocking) {
    attr(design,"I") = IOptimality(as.matrix(designmm),momentsMatrix = mm)
  } else {
    attr(design,"I") = IOptimality(as.matrix(designmm),momentsMatrix = blockedMM)
  }
  attr(design,"model.matrix") = designmm
  attr(design,"generating.model") = model
  attr(design,"generating.criterion") = optimality
  attr(design,"generating.contrast") = contrast

  if(!blocking) {
    rownames(design) = 1:nrow(design)
    colnames(mm) = colnames(designmm)
    rownames(mm) = colnames(designmm)
    attr(design,"moments.matrix") = mm
  } else {
    rownames(design) = rownames(splitPlotReplicateDesign)
    colnames(blockedMM) = colnames(designmm)
    rownames(blockedMM) = colnames(designmm)
    attr(design,"moments.matrix") = blockedMM
  }
  if(ncol(designmm) > 2) {
    correlation.matrix = abs(cov2cor(covarianceMatrix(designmm))[-1,-1])
    colnames(correlation.matrix) = colnames(designmm)[-1]
    rownames(correlation.matrix) = colnames(designmm)[-1]
    attr(design,"correlation.matrix") = round(correlation.matrix,8)
  }

  return(design)
}
globalVariables('i')
