#'@title Generates the optimal run matrix from full factorial, model, optimality criterion,
#'and desired number of runs.
#'
#'@description Creates design given a model and desired number of runs, returning the model matrix. Currently
#'Used with eval_design/eval_design_mc to produce power estimations for designs.
#'
#'@param factorial A full factorial test matrix generated for the factors in the model. If
#'the factor is continuous, it should be type numeric. If the factor is categorical, it should be
#'set as a factor.
#'@param model The model used to generate the test design.
#'@param trials The number of runs in the design.
#'@param wholeblock A data frame specifying the blocking factors.
#'@param blocksize The number of runs in each block.
#'@param optimality The optimality criterion (e.g. "D")
#'@param repeats The number of times to repeat the search for the best optimal condition. If missing, this defaults to 100.
#'@param ... Any additional arguments to be input into AlgDesign's optFederov during design generation.
#'@return The model matrix for the design, to be passed to eval_design. The model matrix
#'has various attributes (accessible with the attr function) that aid evaluation.
#'@import AlgDesign
#'@export
#'@examples #Generate the basic factorial design used in generating the optimal design with
#'#expand.grid.
#'#Generating a basic 2 factor design:
#'basicdesign = expand.grid(x1=c(-1,1),x2=c(-1,1))
#'
#'#We can also generate the factorial using AlgDesign's gen.factorial function.
#'design_gf = AlgDesign::gen.factorial(levels=c(2,2),nVars=2,varNames=c("x1","x2"))
#'
#'#This factorial design is used as an input in the optimal design generation for a
#'#D-optimal design with 11 runs.
#'design = gen_design(factorial=basicdesign,model=~x1+x2,trials=11,optimality="D",repeats=100)
#'
#'#Here we add categorical factors, specified by using "as.factor" in expand.grid:
#'fulldesign = expand.grid(a=c(-1,1),b=as.factor(c("A","B")),c=as.factor(c("High","Med","Low")))
#'
#'#This factorial design is used as an input in the optimal design generation.
#'design2 = gen_design(factorial=fulldesign,model=~a+b+c,trials=19,optimality="D",repeats=100)
#'
#'#We can also decrease the number of repeats searches to increase speed (at the expense of
#'#possibly not having the best optimal design)
#'design2 = gen_design(factorial=fulldesign,model=~a+b+c,trials=19,optimality="D",repeats=5)
#'
#'#You can also use a higher order model when generating the design:
#'design2 = gen_design(factorial=fulldesign,model=~a+b+c+a*b*c,trials=19,optimality="D")
#'
#'#Blocked designs can also be generated by specifying a data frame with the blocking levels
#'#as well as the number of runs per block.
#'
#'#6 blocks
#'blocking = data.frame(Block = as.factor(c(1,2,3,4,5,6)))
#'
#'#5 runs per block
#'designblocked = gen_design(factorial=fulldesign,model=~a+b+c+Block,trials=30,
#'                           wholeblock=blocking, blocksize=5)
#'
#'#A split-plot design can also be generated by first generating a d-optimal blocking design
#'#and then using that as the input for the split-plots.
#'
#'blockfactors = data.frame(Range = as.factor(c("Close","Mid","Far")))
#'blocks = gen_design(factorial = blockfactors, model=~Range, trials=11)
#'
#'#Now we can use the d-optimal blocked design as an input to our full design:
#'
#'designsplitplot = gen_design(factorial=fulldesign,model=~a+b+c+Range,trials=33,
#'                           wholeblock=blocks, blocksize=3)
#'
#'#Alternatively, use of the "Dp" criterion optimizes the product of the determinants of the individual
#'#blocks, which can improve the allocation for individual blocks. For these Dp optimal designs, the "Dp"
#'#attribute is returned as an attribute.
#'
#'designsplitplot = gen_design(factorial=fulldesign,model=~a+b+c+Range,trials=33,
#'                           wholeblock=blocks, blocksize=3,optimality = "Dp")
#'
#'#The optimality numbers can be accessed as an attribute of the run matrix.
#'#See AlgDesign::optFederov documentation for more information.
#'attr(design2,"D") #The kth root of the generalized variance.
#'attr(design2,"A") #The average coefficient variance.
#'attr(design2,"Ge") #The minimax normalized variance.
#'attr(design2,"Dea") #A lower bound on D efficiency for approximate theory designs.
#'
#'#The correlation matrix can be accessed via the "correlation.matrix" attribute:
#'
#'correlation.matrix = attr(design2, "correlation.matrix")
#'
#'#A correlation color map can be produced with the following call to ggplot2 and reshape2
#'
#'\dontrun{melt(correlation.matrix) -> melted.correlation.matrix
#'ggplot(melted.correlation.matrix,aes(x=Var1,y=Var2,fill=value)) + geom_tile() +
#'  scale_fill_gradient2(mid="grey70",high="red", low="blue",midpoint=0.5) +
#'  theme(axis.text.x = element_text(angle = 90, hjust = 1,vjust=0.5))}
#'
#'#The I optimality number is not calculated unless the design is generated as I optimal
#'#or when the evaluateI argument (from AlgDesign's optFederov) is set to TRUE:
#'design3 = gen_design(factorial=fulldesign,model=~a+b+c,trials=19,optimality="I")
#'design3 = gen_design(factorial=fulldesign,model=~a+b+c,trials=19,optimality="D",evaluateI=TRUE)
#'attr(design3,"I") #The average prediction variance over X
#'
#'#Evaluating the design for power can be done with eval_design, eval_design_mc (Monte Carlo)
#'#and eval_design_survival_mc (Monte Carlo survival analysis)
gen_design = function(factorial, model, trials, splitplotdesign = NULL, splitplotsizes = NULL,
                      optimality="D",repeats=5, contrast=contr.simplex, parallel=FALSE,  ...) {

  blocking=FALSE
  #generate blocked design with replicates
  if(!is.null(splitplotdesign)) {
    blocking = TRUE
    if(is.null(splitplotsizes)) {
      stop("If split plot design provided, user needs to input split plot sizes as well")
    }
    if(trials != sum(splitplotsizes)) {
      stop("Blocked replicates does not equal the number of trials input")
    }
    if(nrow(splitplotdesign) != length(splitplotsizes)) {
      stop("Need to specify a size for each row in the given split plot design")
    }
    alreadyBlocking = FALSE
    initialrownames = rownames(splitplotdesign)
    blocklist = strsplit(initialrownames,".",fixed=TRUE)

    if(any(lapply(blocklist,length) > 1)) {
      alreadyBlocking = TRUE
      initialrownames = rep(rownames(splitplotdesign),splitplotsizes)
      blocklist = strsplit(initialrownames,".",fixed=TRUE)
      existingBlockStructure = do.call(rbind,blocklist)
    }
    withinBlockRun = function(runs) {return(1:runs)}

    blockIndicators = rep(1:length(splitplotsizes),splitplotsizes)

    blockvars = colnames(splitplotdesign)
    blocks = list()
    for(i in 1:length(blockIndicators)) {
      blocks[[i]] = splitplotdesign[blockIndicators[i],]
    }
    blockRuns = c()
    for(i in 1:length(splitplotsizes)) {
      blockRuns = c(blockRuns,withinBlockRun(splitplotsizes[i]))
    }

    splitPlotReplicateDesign = as.data.frame(do.call(rbind, blocks))
    colnames(splitPlotReplicateDesign) = blockvars
    if(alreadyBlocking) {
      rownames(splitPlotReplicateDesign) = paste(initialrownames, blockRuns,sep=".")
    } else {
      rownames(splitPlotReplicateDesign) = paste(blockIndicators, blockRuns,sep=".")
    }
  }

  initialReplace = FALSE
  if(trials > nrow(factorial)) {
    initialReplace = TRUE
  }

  genOutput = list(repeats)

  contrastslist = list()
  for(x in names(factorial[sapply(factorial,class) == "factor"])) {
    contrastslist[[x]] = contrast
  }
  if(length(contrastslist) == 0) {
    factorialmm = model.matrix(model,factorial)
  } else {
    factorialmm = model.matrix(model,factorial,contrasts.arg=contrastslist)
  }

  if(!blocking) {
    factors = colnames(factorialmm)
    mm = gen_momentsmatrix(factors)
    if(!parallel) {
      for(i in 1:repeats) {
        randomIndices = sample(nrow(factorialmm), trials, replace = initialReplace)
        genOutput[[i]] = genOptimalDesign(initialdesign = factorialmm[randomIndices,], candidatelist=factorialmm,
                                        condition=optimality, momentsmatrix = mm, initialRows = randomIndices)
      }
    } else {
      cl <- parallel::makeCluster(parallel::detectCores())
      doParallel::registerDoParallel(cl, cores = parallel::detectCores())

      genOutput = foreach(i=1:repeats) %dopar% {
        randomIndices = sample(nrow(factorialmm), trials, replace = initialReplace)
        genOptimalDesign(initialdesign = factorialmm[randomIndices,], candidatelist=factorialmm,
                         condition=optimality, momentsmatrix = mm, initialRows = randomIndices)
      }
      parallel::stopCluster(cl)
    }
  } else {
    blockedContrastsList = list()
    for(x in names(splitPlotReplicateDesign[sapply(splitPlotReplicateDesign,class) == "factor"])) {
      blockedContrastsList[x] = contrast
    }
    if(length(blockedContrastsList) == 0) {
      blockedModelMatrix = model.matrix(~.,splitPlotReplicateDesign)
    } else {
      blockedModelMatrix = model.matrix(~.,splitPlotReplicateDesign,contrasts.arg=blockedContrastsList)
    }
    blockedFactors = c(colnames(blockedModelMatrix),colnames(factorialmm)[-1])
    blockedMM = gen_momentsmatrix(blockedFactors)
    if (!parallel) {
      for(i in 1:repeats) {
        randomIndices = sample(nrow(factorial), trials, replace = initialReplace)
        genOutput[[i]] = genBlockedOptimalDesign(initialdesign = factorialmm[randomIndices,],
                                                 candidatelist=factorialmm, blockeddesign = blockedModelMatrix,
                                                 condition=optimality, momentsmatrix = blockedMM, initialRows = randomIndices)
      }
    } else {
      cl <- parallel::makeCluster(parallel::detectCores())
      doParallel::registerDoParallel(cl, cores = parallel::detectCores())

      genOutput = foreach(i=1:repeats) %dopar% {
        randomIndices = sample(nrow(factorial), trials, replace = initialReplace)
        genBlockedOptimalDesign(initialdesign = factorialmm[randomIndices,],
                                candidatelist=factorialmm, blockeddesign = blockedModelMatrix,
                                condition=optimality, momentsmatrix = blockedMM, initialRows = randomIndices)
      }
      parallel::stopCluster(cl)
    }
  }

  designs = list(repeats)
  rowIndicies = list(repeats)
  criteria = list(repeats)

  for(i in 1:repeats) {
    designs[i] = genOutput[[i]]["modelmatrix"]
    rowIndicies[i] = genOutput[[i]]["indices"]
    criteria[i] = genOutput[[i]]["criterion"]
  }

  if(optimality == "D") {
    best = which.max(criteria)
    designmm = designs[[best]]
    rowindex = rowIndicies[[best]]
  }

  if(optimality == "A" || optimality == "I") {
    best = which.min(criteria)
    designmm = designs[[best]]
    rowindex = rowIndicies[[best]]
  }

  if(!blocking) {
    colnames(designmm) = factors
  } else {
    colnames(designmm) = blockedFactors
  }

  design = constructRunMatrix(rowIndices = rowindex, candidateList = factorial)

  if(blocking) {
    design = cbind(splitPlotReplicateDesign,design)
  }
  attr(design,"D-Efficiency") = 100*DOptimality(designmm)^(1/ncol(designmm))/nrow(designmm)
  attr(design,"A-Efficiency") = AOptimality(designmm)
  if(!blocking) {
    attr(design,"I") = IOptimality(as.matrix(designmm),momentsMatrix = mm)
  } else {
    attr(design,"I") = IOptimality(as.matrix(designmm),momentsMatrix = blockedMM)
  }
  attr(design,"model.matrix") = designmm
  attr(design,"generating.model") = model
  attr(design,"generating.criterion") = optimality
  attr(design,"generating.contrast") = contrast

  if(!blocking) {
    rownames(design) = 1:nrow(design)
    colnames(mm) = colnames(designmm)
    rownames(mm) = colnames(designmm)
    attr(design,"moments.matrix") = mm
  } else {
    rownames(design) = rownames(splitPlotReplicateDesign)
    colnames(blockedMM) = colnames(designmm)
    rownames(blockedMM) = colnames(designmm)
    attr(design,"moments.matrix") = blockedMM
  }
  correlation.matrix = abs(cov2cor(covarianceMatrix(designmm))[-1,-1])
  colnames(correlation.matrix) = colnames(designmm)[-1]
  rownames(correlation.matrix) = colnames(designmm)[-1]
  attr(design,"correlation.matrix") = correlation.matrix

  return(design)
}
globalVariables('i')
