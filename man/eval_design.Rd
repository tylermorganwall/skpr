% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/eval_design.R
\name{eval_design}
\alias{eval_design}
\title{Calculates Power Given a Run Matrix}
\usage{
eval_design(RunMatrix, model, alpha, blockmodel = NULL, anticoef = NULL,
  delta = 2, varianceratio = 1, contrasts = "contr.sum",
  conservative = FALSE)
}
\arguments{
\item{RunMatrix}{The run matrix being evaluated.}

\item{model}{The model used in evaluating the design. It can be a subset of the model used to
generate the design, or include higher order effects not in the original design generation.}

\item{alpha}{The specified type-I error.}

\item{blockmodel}{A formula specifing the blocking factors.}

\item{anticoef}{The anticipated coefficients for calculating the power. If missing, coefficients
will be automatically generated based on the delta argument.}

\item{delta}{The signal-to-noise ratio. Default 2. This specifies the difference between the high
and low levels. If you do not specify anticoef, the anticipated coefficients will be half of delta. If you do specify anticoef, leave delta at its default of 2.}

\item{varianceratio}{Default 1. The ratio of the whole plot variance to the run-to-run variance.}

\item{contrasts}{A string specifying how to treat the contrasts in calculating the model matrix.}

\item{conservative}{Default FALSE. Specifies whether default method for generating
anticipated coefficents should be conservative or not. TRUE will give the most conservative
estimate of power by setting all but one level in a categorical factor's anticipated coefficients
to zero.}
}
\value{
A data frame with the parameters of the model, the type of power analysis, and the power.
}
\description{
Evaluates a design given a run matrix and returns
a data frame of parameter and effect powers. Designs can
consist of both continuous and categorical factors. Default
assumes a signal-to-noise ratio of 2 (can be changed with the
delta parameter).
}
\examples{
#Generating a simple 2x3 factorial to feed into our optimal design generation
#of an 11-run design.
factorial <- expand.grid(A=c(1,-1),B=c(1,-1),C=c(1,-1))

optdesign = gen_design(factorial=factorial, model= ~A+B+C,trials=11,optimality="D",repeats=100)

#Now evaluating that design (with default anticipated coefficients and a delta of 2):
eval_design(RunMatrix=optdesign, model= ~A+B+C, alpha=0.2)

#Evaluating a subset of the design (changing the power due to a different number of
#degrees of freedom)
eval_design(RunMatrix=optdesign, model= ~A+C, alpha=0.2)

#Halving the signal-to-noise ratio by setting a different delta (default is 2):
eval_design(RunMatrix=optdesign, model= ~A+B+C, alpha=0.2,delta=1)

#With 3+ level categorical factors, the choice of anticipated coefficients directly changes the
#final power calculation. For the most conservative power calculation, that involves
#setting all anticipated coefficients in a factor to zero except for one. We can specify this
#option with the "conservative" argument.

factorialcoffee = expand.grid(cost=c(1,2),
                             type=as.factor(c("Kona","Colombian","Ethiopian","Sumatra")),
                             size=as.factor(c("Short","Grande","Venti")))

designcoffee = gen_design(factorialcoffee,~cost + size + type,trials=29,optimality="D",repeats=100)

#Evaluate the design, with default anticipated coefficients (conservative is FALSE by default).
eval_design(designcoffee,model=~cost+size+type, alpha=0.05)

#Evaluate the design, with conservative anticipated coefficients:
eval_design(designcoffee,model=~cost+size+type, alpha=0.05,conservative=TRUE)

#which is the same as the following, but now explicitly entering the coefficients:
eval_design(designcoffee,model=~cost+size+type, alpha=0.05,anticoef=c(1,1,1,0,0,1,0))

#If the first level in a factor is not the one that you want to set to one
#in the conservative calculation, enter the anticipated coefficients in manually.
eval_design(designcoffee,model=~cost+size+type, alpha=0.05,anticoef=c(1,1,0,0,1,0,1))

#You can also evaluate the design with higher order effects:
eval_design(designcoffee,model=~cost+size+type+cost*type, alpha=0.05)

#Split plot designs can also be evaluated by specifying the blocking model.

#Generating split plot design
coffeeblocks = expand.grid(caffeine=c(1,-1))
coffeeblockdesign = gen_design(coffeeblocks, ~caffeine, trials=12)
coffeefinaldesign = gen_design(factorialcoffee, model=~cost+size+type,trials=36,
                              splitplotdesign=coffeeblockdesign, splitplotsizes=rep(3,12))

#Evaluating design
eval_design(coffeefinaldesign, ~cost+size+type + caffeine, 0.2, blockmodel= ~caffeine)

#We can also evaluate the design with a custom ratio between the whole plot error to
#the run-to-run error.
eval_design(coffeefinaldesign, ~cost+size+type + caffeine, 0.2, blockmodel= ~caffeine,
           varianceratio=2)
}

