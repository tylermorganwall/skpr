% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/eval_design_mc.R
\name{eval_design_mc}
\alias{eval_design_mc}
\title{Evaluates power for model matrix with a Monte Carlo simulation}
\usage{
eval_design_mc(RunMatrix, model, alpha, nsim, glmfamily, rfunction, anticoef,
  delta = 2, conservative = FALSE, parallel = FALSE)
}
\arguments{
\item{RunMatrix}{The run matrix of the design.}

\item{model}{The model used in the evaluation.}

\item{alpha}{The type-I error.}

\item{nsim}{The number of simulations.}

\item{glmfamily}{String indicating the family the distribution is from for the glm function
(e.g. gaussian, binomial, poisson)}

\item{rfunction}{Random number generator function. Should be a function of the form f(X,b), where X is the
model matrix and b are the anticipated coefficients.}

\item{anticoef}{The anticipated coefficients for calculating the power. If missing, coefficients will be
automatically generated.}

\item{delta}{The signal-to-noise ratio. Default 2. This specifies the difference between the high and low levels.
Anticipated coefficients will be half of this number.}

\item{conservative}{Default FALSE. Specifies whether default method for generating
anticipated coefficents should be conservative or not. TRUE will give the most conservative
estimate of power by setting all but one level in a categorical factor's anticipated coefficients
to zero.}

\item{parallel}{Default FALSE. If TRUE, uses all cores available to speed up computation of power.}
}
\value{
A data frame consisting of the parameters and their powers
}
\description{
Evaluates design given a model matrix with a monte carlo simulation and returns
a data frame of parameter powers. Currently only works with linear, non-interacting models.
}
\examples{
#We first generate a full factorial design using expand.grid:
factorialcoffee = expand.grid(cost=c(-1,1),
                             type=as.factor(c("Kona","Colombian","Ethiopian","Sumatra")),
                             size=as.factor(c("Short","Grande","Venti")))

#And then generate the 21-run D-optimal design using gen_design.

designcoffee = gen_design(factorialcoffee,~cost + type + size,21,"D",100)

#To evaluate this design using a normal approximation, we just use eval_design
#(here using the default settings for contrasts, delta, and the anticipated coefficients):

eval_design(RunMatrix=designcoffee,model=~cost + type + size, 0.05)

#We want to evaluate this design with a Monte Carlo approach. In this case, we need
#to create a function that generates random numbers based on our run matrix X and
#our anticipated coefficients (b).

rgen = function(X,b) {
 return(rnorm(n=nrow(X),mean = X \%*\% b, sd = 1))
}

#Here we generate our nrow(X) random numbers from a population with a mean that varies depending
#on the design (and is set by multiplying the run matrix X with the anticipated coefficients
#vector b), and has a standard deviation of one. To evaluate this, we enter the same information
#used in eval_design, with the addition of the number of simulations "nsim", the distribution
#family used in fitting for the glm "glmfamily", the custom random generation function "rfunction",
#and whether or not we want the computation to be done with all the cores available "parallel".

eval_design_mc(RunMatrix=designcoffee,model=~cost + type + size, alpha=0.05,
              nsim=1000,glmfamily="gaussian",rfunction=rgen)

#We see here we generate approximately the same parameter powers as we do
#using the normal approximation in eval_design. Like eval_design, we can also change
#delta to produce a different signal-to-noise ratio:

eval_design_mc(RunMatrix=designcoffee,model=~cost + type + size, alpha=0.05,
              nsim=1000,glmfamily="gaussian",rfunction=rgen,delta=1)

#However, we could also specify this using a different random generator function by
#doubling the standard deviation of the population we are drawing from:

rgensnr = function(X,b) {
 return(rnorm(n=nrow(X),mean = X \%*\% b, sd = 2))
}

eval_design_mc(RunMatrix=designcoffee,model=~cost + type + size, alpha=0.05,
              nsim=1000,glmfamily="gaussian",rfunction=rgensnr)

#Both methods provide the same end result.

#Like eval_design, we can also evaluate the design with a different model than
#the one that generated the design.
eval_design_mc(RunMatrix=designcoffee,model=~cost + type, 0.05,
              nsim=1000,glmfamily="gaussian",rfunction=rgen)

#Here we evaluate the design using conservative anticipated coefficients:
eval_design_mc(RunMatrix=designcoffee,model=~cost + type + size, 0.05,
              nsim=1000,glmfamily="gaussian",rfunction=rgen,conservative=TRUE)

#We can also set "parallel=TRUE" to turn use all the cores available to speed up
#computation.
\dontrun{eval_design_mc(RunMatrix=designcoffee,model=~cost + type + size, 0.05,
              nsim=1000,glmfamily="gaussian",rfunction=rgen,parallel=TRUE)}

#We can also use this method to evaluate designs that cannot be easily
#evaluated using normal approximations. Here, we evaluate a design and see
#if we can detect the difference between each factor changing whether an event
#70\% of the time or 90\% of the time.

factorialbinom = expand.grid(a=c(-1,1),b=c(-1,1))
designbinom = gen_design(factorialbinom,~a+b,90,"D",100)

#Here our random binomial generator simulates a response based on the resulting
#probability from of all the columns in one row influencing the result.

rgenbinom = function(X,b) {
 rbinom(n=nrow(X),size=1,prob = exp(X \%*\% b)/(1+exp(X \%*\% b)))
}

#Plugging everything in, we now evaluate our model and obtain the binomial power.
#(the anticipated coefficients were determined empircally to set the
#high and low probabilities correctly for each factor)

eval_design_mc(designbinom,~a+b,0.2,nsim=1000,anticoef=c(1.5,0.7,0.7),
              glmfamily="binomial",rfunction=rgenbinom)

#We can also use this method to determine power for poisson response variables.
#Assume we have an event that occurs either every half minute, once a minute,
#or once every minute and a half. Our design matrix is as such:

factorialpois = expand.grid(a=c(0.5,1,1.5),b=c(0.5,1,1.5))
designpois = gen_design(factorialpois,~a+b, 90,"D",1000)


#Here we return a random poisson number of events that vary depending
#on the rate in the design.
rrate = function(X,b) {
 return(rpois(n=nrow(X),lambda=X\%*\%b))
}
eval_design_mc(designpois,~a+b,0.2,nsim=1000,glmfamily="poisson",rfunction=rrate)
#We see here we need about 90 test events to get accurately distinguish the three different
#rates in each factor to 80\% power.
}

