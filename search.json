[{"path":"https://tylermorganwall.github.io/skpr/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Tyler Morgan-Wall. Author, maintainer. George Khoury. Author.","code":""},{"path":"https://tylermorganwall.github.io/skpr/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Morgan-Wall T, Khoury G (2021). “Optimal Design Generation Power Evaluation R: skpr Package.” Journal Statistical Software, 99(1), 1–36. doi:10.18637/jss.v099.i01.","code":"@Article{,   title = {Optimal Design Generation and Power Evaluation in {R}: The {skpr} Package},   author = {Tyler Morgan-Wall and George Khoury},   journal = {Journal of Statistical Software},   year = {2021},   volume = {99},   number = {1},   pages = {1--36},   doi = {10.18637/jss.v099.i01}, }"},{"path":[]},{"path":"https://tylermorganwall.github.io/skpr/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"Design of Experiments Suite: Generate and Evaluate Optimal Designs","text":"skpr open source design experiments suite generating evaluating optimal designs R. sampling skpr offers: Generates evaluates D, , , Alias, E, T, G optimal designs, well user-defined custom optimality criteria. Supports generation evaluation split/split-split/…/N-split plot designs. Includes parametric Monte Carlo power evaluation functions, supports calculating power censored responses. Provides extensible framework user evaluate Monte Carlo power using libraries. Includes Shiny graphical user interface, skprGUI, auto-generates R code used create evaluate design improve ease--use enhance reproducibility.","code":""},{"path":"https://tylermorganwall.github.io/skpr/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Design of Experiments Suite: Generate and Evaluate Optimal Designs","text":"","code":"# To install: install.packages(\"skpr\")  # To install the latest version from Github: # install.packages(\"devtools\") devtools::install_github(\"tylermorganwall/skpr\")"},{"path":"https://tylermorganwall.github.io/skpr/index.html","id":"functions","dir":"","previous_headings":"","what":"Functions","title":"Design of Experiments Suite: Generate and Evaluate Optimal Designs","text":"gen_design() generates optimal designs candidate set, given model desired number runs. eval_design() evaluates power parametrically linear models, normal split-plot designs. eval_design_mc() evaluates power Monte Carlo simulation, linear generalized linear models. function also supports calculating power split-plot designs using REML. eval_design_survival_mc() evaluates power Monte Carlo simulation, allowing user specify point data censored. eval_design_custom_mc() allows user import libraries use Monte Carlo framework provided skpr calculate power. calculate_power_curves() provides interface automate generation evaluation designs create power versus sample size effect size curves. skprGUI() opens GUI either RStudio external browser. addition, package offers two functions generate common plots related designs: plot_correlations() generates color map correlations variables. plot_fds() generates fraction design space plot given design. ##skprGUI skprGUI() provides graphical user interface access main features skpr. interactive tutorial provided familiarize user available functionality. Type skprGUI() begin. Screenshots:","code":""},{"path":"https://tylermorganwall.github.io/skpr/index.html","id":"usage","dir":"","previous_headings":"","what":"Usage","title":"Design of Experiments Suite: Generate and Evaluate Optimal Designs","text":"","code":"library(skpr)  #Generate a candidate set of all potential design points to be considered in the experiment #The hypothetical experiment is determining what affects the caffeine content in coffee candidate_set = expand.grid(temp = c(80,90,100),                              type = c(\"Kona\",\"Java\"),                             beansize = c(\"Large\",\"Medium\",\"Small\")) candidate_set #>    temp type beansize #> 1    80 Kona    Large #> 2    90 Kona    Large #> 3   100 Kona    Large #> 4    80 Java    Large #> 5    90 Java    Large #> 6   100 Java    Large #> 7    80 Kona   Medium #> 8    90 Kona   Medium #> 9   100 Kona   Medium #> 10   80 Java   Medium #> 11   90 Java   Medium #> 12  100 Java   Medium #> 13   80 Kona    Small #> 14   90 Kona    Small #> 15  100 Kona    Small #> 16   80 Java    Small #> 17   90 Java    Small #> 18  100 Java    Small  #Generate the design (default D-optimal) design = gen_design(candidateset = candidate_set,                      model = ~temp + type + beansize,                     trials=12) design #>    temp type beansize #> 1    80 Java   Medium #> 2   100 Java    Large #> 3   100 Java    Small #> 4    80 Java    Large #> 5    80 Kona   Medium #> 6    80 Kona    Small #> 7   100 Kona    Small #> 8   100 Kona   Medium #> 9    80 Kona    Large #> 10  100 Java   Medium #> 11  100 Kona    Large #> 12   80 Java    Small  #Evaluate power for the design with an allowable type-I error of 5% (default) eval_design(design) #>     parameter            type     power #> 1 (Intercept)    effect.power 0.8424665 #> 2        temp    effect.power 0.8424665 #> 3        type    effect.power 0.8424665 #> 4    beansize    effect.power 0.5165386 #> 5 (Intercept) parameter.power 0.8424665 #> 6        temp parameter.power 0.8424665 #> 7       type1 parameter.power 0.8424665 #> 8   beansize1 parameter.power 0.5593966 #> 9   beansize2 parameter.power 0.5593966 #> ============Evaluation Info============ #> * Alpha = 0.05 * Trials = 12 * Blocked = FALSE  #> * Evaluating Model = ~temp + type + beansize  #> * Anticipated Coefficients = c(1, 1, 1, 1, -1)  #> * Contrasts = `contr.sum`  #> * Parameter Analysis Method = `lm(...)`  #> * Effect Analysis Method = `car::Anova(fit, type = \"III\")`  #Evaluate power for the design using a Monte Carlo simulation.  #Here, we set the effect size (here, the signal-to-noise ratio) to 1.5. eval_design_mc(design, effectsize=1.5) #>     parameter               type power #> 1 (Intercept)    effect.power.mc 0.600 #> 2        temp    effect.power.mc 0.612 #> 3        type    effect.power.mc 0.610 #> 4    beansize    effect.power.mc 0.316 #> 5 (Intercept) parameter.power.mc 0.600 #> 6        temp parameter.power.mc 0.612 #> 7       type1 parameter.power.mc 0.610 #> 8   beansize1 parameter.power.mc 0.359 #> 9   beansize2 parameter.power.mc 0.354 #> ===========Evaluation Info============ #> * Alpha = 0.05 * Trials = 12 * Blocked = FALSE  #> * Evaluating Model = ~temp + type + beansize  #> * Anticipated Coefficients = c(0.750, 0.750, 0.750, 0.750, -0.750)  #> * Contrasts = `contr.sum`  #> * Parameter Analysis Method = `lm(...)`  #> * Effect Analysis Method = `car::Anova(fit, type = \"III\")`  #Evaluate power for the design using a Monte Carlo simulation, for a non-normal response.  #Here, we also increase the number of simululations to improve the precision of the results. eval_design_mc(design, nsim=5000, glmfamily = \"poisson\", effectsize=c(2,6)) #>     parameter               type  power #> 1 (Intercept)    effect.power.mc 0.9968 #> 2        temp    effect.power.mc 0.9826 #> 3        type    effect.power.mc 0.9832 #> 4    beansize    effect.power.mc 0.8502 #> 5 (Intercept) parameter.power.mc 0.9968 #> 6        temp parameter.power.mc 0.9826 #> 7       type1 parameter.power.mc 0.9832 #> 8   beansize1 parameter.power.mc 0.8842 #> 9   beansize2 parameter.power.mc 0.7052 #> ============Evaluation Info============ #> * Alpha = 0.05 * Trials = 12 * Blocked = FALSE  #> * Evaluating Model = ~temp + type + beansize  #> * Anticipated Coefficients = c(1.242, 0.549, 0.549, 0.549, -0.549)  #> * Contrasts = `contr.sum`  #> * Parameter Analysis Method = `glm(..., family = \"poisson\")`  #> * Effect Analysis Method = `car::Anova(fit, type = \"III\")`  #skpr was designed to operate with the pipe (|>) in mind.  #Here is an example of an entire design of experiments analysis in three lines:  expand.grid(temp = c(80,90,100), type = c(\"Kona\",\"Java\"), beansize = c(\"Large\",\"Medium\",\"Small\")) |>   gen_design(model = ~temp + type + beansize + beansize:type + I(temp^2), trials=24, optimality=\"I\") |>   eval_design_mc(detailedoutput = TRUE) #>          parameter               type power anticoef alpha glmfamily trials #> 1      (Intercept)    effect.power.mc 0.912       NA  0.05  gaussian     24 #> 2             temp    effect.power.mc 0.927       NA  0.05  gaussian     24 #> 3             type    effect.power.mc 0.997       NA  0.05  gaussian     24 #> 4         beansize    effect.power.mc 0.935       NA  0.05  gaussian     24 #> 5        I(temp^2)    effect.power.mc 0.637       NA  0.05  gaussian     24 #> 6    type:beansize    effect.power.mc 0.913       NA  0.05  gaussian     24 #> 7      (Intercept) parameter.power.mc 0.912        1  0.05  gaussian     24 #> 8             temp parameter.power.mc 0.927        1  0.05  gaussian     24 #> 9            type1 parameter.power.mc 0.997        1  0.05  gaussian     24 #> 10       beansize1 parameter.power.mc 0.917        1  0.05  gaussian     24 #> 11       beansize2 parameter.power.mc 0.913       -1  0.05  gaussian     24 #> 12       I(temp^2) parameter.power.mc 0.637        1  0.05  gaussian     24 #> 13 type1:beansize1 parameter.power.mc 0.899        1  0.05  gaussian     24 #> 14 type1:beansize2 parameter.power.mc 0.902       -1  0.05  gaussian     24 #>    nsim blocking error_adjusted_alpha power_lcb power_ucb #> 1  1000    FALSE                 0.05 0.8927052 0.9288249 #> 2  1000    FALSE                 0.05 0.9090858 0.9423464 #> 3  1000    FALSE                 0.05 0.9912580 0.9993809 #> 4  1000    FALSE                 0.05 0.9178989 0.9494797 #> 5  1000    FALSE                 0.05 0.6063275 0.6668632 #> 6  1000    FALSE                 0.05 0.8937921 0.9297315 #> 7  1000    FALSE                 0.05 0.8927052 0.9288249 #> 8  1000    FALSE                 0.05 0.9090858 0.9423464 #> 9  1000    FALSE                 0.05 0.9912580 0.9993809 #> 10 1000    FALSE                 0.05 0.8981467 0.9333511 #> 11 1000    FALSE                 0.05 0.8937921 0.9297315 #> 12 1000    FALSE                 0.05 0.6063275 0.6668632 #> 13 1000    FALSE                 0.05 0.8786332 0.9169799 #> 14 1000    FALSE                 0.05 0.8818715 0.9197225 #> =========================================================Evaluation Info========================================================== #> * Alpha = 0.05 * Trials = 24 * Blocked = FALSE  #> * Evaluating Model = ~temp + type + beansize + type:beansize + I(temp^2)  #> * Anticipated Coefficients = c(1, 1, 1, 1, -1, 1, 1, -1)  #> * Contrasts = `contr.sum`  #> * Parameter Analysis Method = `lm(...)`  #> * Effect Analysis Method = `car::Anova(fit, type = \"III\")`  #> * MC Power CI Confidence = 95%"},{"path":"https://tylermorganwall.github.io/skpr/reference/add_ci_bounds_mc_power.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate CI bounds on Monte Carlo — add_ci_bounds_mc_power","title":"Calculate CI bounds on Monte Carlo — add_ci_bounds_mc_power","text":"Calculates CI bounds Monte Carlo power","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/add_ci_bounds_mc_power.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate CI bounds on Monte Carlo — add_ci_bounds_mc_power","text":"","code":"add_ci_bounds_mc_power(power_results, nsim, conf = 0.95)"},{"path":"https://tylermorganwall.github.io/skpr/reference/add_ci_bounds_mc_power.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate CI bounds on Monte Carlo — add_ci_bounds_mc_power","text":"Power data.frame conf intervals","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/aliasmodel.html","id":null,"dir":"Reference","previous_headings":"","what":"Alias terms — aliasmodel","title":"Alias terms — aliasmodel","text":"Creates alias terms Alias-optimal designs","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/aliasmodel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Alias terms — aliasmodel","text":"","code":"aliasmodel(formula, power)"},{"path":"https://tylermorganwall.github.io/skpr/reference/aliasmodel.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Alias terms — aliasmodel","text":"formula formula expanded","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/aliasmodel.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Alias terms — aliasmodel","text":"Returns aliased model terms formula","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/anticoef_from_delta.html","id":null,"dir":"Reference","previous_headings":"","what":"Generates Anticipated Coefficients from delta — anticoef_from_delta","title":"Generates Anticipated Coefficients from delta — anticoef_from_delta","text":"Generates Anticipated Coefficients delta parameter logic generating anticipated coefficients delta varies glm family.","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/anticoef_from_delta.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generates Anticipated Coefficients from delta — anticoef_from_delta","text":"","code":"anticoef_from_delta(default_coef, delta, glmfamily)"},{"path":"https://tylermorganwall.github.io/skpr/reference/anticoef_from_delta.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generates Anticipated Coefficients from delta — anticoef_from_delta","text":"default_coef vector default coefficients, gen_anticoef delta user-input delta parameter, must numeric vector length 1 2 glmfamily user-supplied glmfamily, either string glmfamily object","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/anticoef_from_delta.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generates Anticipated Coefficients from delta — anticoef_from_delta","text":"Anticipated coefficients.","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/anticoef_from_delta_surv.html","id":null,"dir":"Reference","previous_headings":"","what":"Generates Anticipated Coefficients from delta for eval_design_suvival_mc — anticoef_from_delta_surv","title":"Generates Anticipated Coefficients from delta for eval_design_suvival_mc — anticoef_from_delta_surv","text":"Generates Anticipated Coefficients delta parameter logic generating anticipated coefficients delta varies glm family.","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/anticoef_from_delta_surv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generates Anticipated Coefficients from delta for eval_design_suvival_mc — anticoef_from_delta_surv","text":"","code":"anticoef_from_delta_surv(default_coef, delta, distribution)"},{"path":"https://tylermorganwall.github.io/skpr/reference/anticoef_from_delta_surv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generates Anticipated Coefficients from delta for eval_design_suvival_mc — anticoef_from_delta_surv","text":"default_coef vector default coefficients, gen_anticoef delta user-input delta parameter, must numeric vector length 1 2 distribution user-supplied distribution, either string survreg distribution object","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/anticoef_from_delta_surv.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generates Anticipated Coefficients from delta for eval_design_suvival_mc — anticoef_from_delta_surv","text":"Anticipated coefficients.","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/blockingstructure.html","id":null,"dir":"Reference","previous_headings":"","what":"Find block sizes in column — blockingstructure","title":"Find block sizes in column — blockingstructure","text":"Returns blocks","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/blockingstructure.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find block sizes in column — blockingstructure","text":"","code":"blockingstructure(blocklist)"},{"path":"https://tylermorganwall.github.io/skpr/reference/blockingstructure.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find block sizes in column — blockingstructure","text":"blocklist Block list","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/blockingstructure.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find block sizes in column — blockingstructure","text":"Returns blocking structure given vector block ids","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/calc_conservative_anticoef.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Conservative Anticipated Coefficients — calc_conservative_anticoef","title":"Calculate Conservative Anticipated Coefficients — calc_conservative_anticoef","text":"Calculate Conservative Anticipated Coefficients","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/calc_conservative_anticoef.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Conservative Anticipated Coefficients — calc_conservative_anticoef","text":"","code":"calc_conservative_anticoef(results, effectsize)"},{"path":"https://tylermorganwall.github.io/skpr/reference/calc_conservative_anticoef.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Conservative Anticipated Coefficients — calc_conservative_anticoef","text":"results power results matrix effectsize effectsize.","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/calc_conservative_anticoef.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Conservative Anticipated Coefficients — calc_conservative_anticoef","text":"Vector conservative anticipated coefficients","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/calc_interaction_degrees.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Interaction Degrees of Freedom — calc_interaction_degrees","title":"Calculate Interaction Degrees of Freedom — calc_interaction_degrees","text":"Calculate interaction degrees freedom split-plot designs","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/calc_interaction_degrees.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Interaction Degrees of Freedom — calc_interaction_degrees","text":"","code":"calc_interaction_degrees(   design,   model,   contrast,   nointercept,   split_layers,   split_degrees,   split_plot_structure )"},{"path":"https://tylermorganwall.github.io/skpr/reference/calc_interaction_degrees.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Interaction Degrees of Freedom — calc_interaction_degrees","text":"design design matrix model model contrast contrast split_layers layer split plots main effect term split_degrees number degrees freedom main effect term","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/calc_interaction_degrees.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Interaction Degrees of Freedom — calc_interaction_degrees","text":"Degrees freedom vector","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/calcblocksizes.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate block sizes — calcblocksizes","title":"Calculate block sizes — calcblocksizes","text":"Calculate block size vector","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/calcblocksizes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate block sizes — calcblocksizes","text":"","code":"calcblocksizes(trials, blocksize)"},{"path":"https://tylermorganwall.github.io/skpr/reference/calcblocksizes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate block sizes — calcblocksizes","text":"trials Number trials design blocksize desired size block","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/calcblocksizes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate block sizes — calcblocksizes","text":"blocksize vector","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/calcnoncentralparam.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Non-Centrality Parameter — calcnoncentralparam","title":"Calculate Non-Centrality Parameter — calcnoncentralparam","text":"Calculates non-centrality parameter model matrix","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/calcnoncentralparam.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Non-Centrality Parameter — calcnoncentralparam","text":"","code":"calcnoncentralparam(X, L, b, vinv = NULL)"},{"path":"https://tylermorganwall.github.io/skpr/reference/calcnoncentralparam.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Non-Centrality Parameter — calcnoncentralparam","text":"X model matrix L parameter matrix/vector b anticipated coefficients vinv variance-covariance matrix","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/calcnoncentralparam.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Non-Centrality Parameter — calcnoncentralparam","text":"non-centrality parameter F test","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/calculate_block_nesting.html","id":null,"dir":"Reference","previous_headings":"","what":"Determine Nesting Level of Blocks — calculate_block_nesting","title":"Determine Nesting Level of Blocks — calculate_block_nesting","text":"Calculates block fully nested within another block, highest level nesting . 1 indicates block nested within another block–just within intercept.","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/calculate_block_nesting.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Determine Nesting Level of Blocks — calculate_block_nesting","text":"","code":"calculate_block_nesting(blockgroups, blockstructure)"},{"path":"https://tylermorganwall.github.io/skpr/reference/calculate_block_nesting.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Determine Nesting Level of Blocks — calculate_block_nesting","text":"Vector numbers indicating hierarchy","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/calculate_degrees_of_freedom.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Degrees of Freedom — calculate_degrees_of_freedom","title":"Calculate Degrees of Freedom — calculate_degrees_of_freedom","text":"Calculates degrees freedom adjustment models random effects Penheiro Bates, pg. 91","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/calculate_degrees_of_freedom.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Degrees of Freedom — calculate_degrees_of_freedom","text":"","code":"calculate_degrees_of_freedom(   run_matrix_processed,   nointercept,   model,   contrasts )"},{"path":"https://tylermorganwall.github.io/skpr/reference/calculate_degrees_of_freedom.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Degrees of Freedom — calculate_degrees_of_freedom","text":"run_matrix_processed design nointercept Whether intercept term present","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/calculate_degrees_of_freedom.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Degrees of Freedom — calculate_degrees_of_freedom","text":"Vector numbers indicating split plot layers","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/calculate_gefficiency.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate G Efficiency — calculate_gefficiency","title":"Calculate G Efficiency — calculate_gefficiency","text":"Either calculates G-Efficiency Monte Carlo sampling design space (ignoring constraints), searching maximum point (slower higher quality), using user-specified candidate set design space (fastest).","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/calculate_gefficiency.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate G Efficiency — calculate_gefficiency","text":"","code":"calculate_gefficiency(   design,   calculation_type = \"random\",   randsearches = 10000,   design_space_mm = NULL )"},{"path":"https://tylermorganwall.github.io/skpr/reference/calculate_gefficiency.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate G Efficiency — calculate_gefficiency","text":"Normalized run matrix","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/calculate_level_vector.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate level vector — calculate_level_vector","title":"Calculate level vector — calculate_level_vector","text":"Calculate level vector","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/calculate_level_vector.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate level vector — calculate_level_vector","text":"","code":"calculate_level_vector(design, model, nointercept)"},{"path":"https://tylermorganwall.github.io/skpr/reference/calculate_level_vector.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate level vector — calculate_level_vector","text":"design Design analyzed. model model. nointercept Whether intercept included.","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/calculate_level_vector.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate level vector — calculate_level_vector","text":"vector levels.","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/calculate_level_vector.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate level vector — calculate_level_vector","text":"","code":"#We can pass either the output of gen_design or eval_design to plot_correlations"},{"path":"https://tylermorganwall.github.io/skpr/reference/calculate_power_curves.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Power Curves — calculate_power_curves","title":"Calculate Power Curves — calculate_power_curves","text":"Calculate optionally plot power curves different effect sizes trial counts. function takes ","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/calculate_power_curves.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Power Curves — calculate_power_curves","text":"","code":"calculate_power_curves(   trials,   effectsize = 1,   candidateset = NULL,   model = NULL,   alpha = 0.05,   gen_args = list(),   eval_function = \"eval_design\",   eval_args = list(),   random_seed = 123,   iterate_seed = FALSE,   plot_results = TRUE,   auto_scale = TRUE,   x_breaks = NULL,   y_breaks = seq(0, 1, by = 0.1),   ggplot_elements = list() )"},{"path":"https://tylermorganwall.github.io/skpr/reference/calculate_power_curves.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Power Curves — calculate_power_curves","text":"trials numeric vector indicating trial(s) used computing power curve. single value, fixed `effectsize` varied. effectsize Default `1`. numeric vector indicating effect size(s) used computing power curve. single value, fixed `trials` varied. using length-2 effect size `eval_design_mc()` (binomial probability interval), effect size pairs can input entries list. candidateset Default `NULL`. candidate set (see `gen_design()` documentation information). Provided aid code completion: can also provided `gen_args`. model Default `NULL`. model (see `gen_design()` `eval_design()` documentation information). Provided aid code completion: can also provided `gen_args`/`eval_args`. alpha Default `0.05`. allowable Type-error rate (see `eval_design()` documentation information). Provided aid code completion: can also provided `eval_args`. gen_args Default `list()`. list argument/value pairs specify design generation parameters `gen_design()`. eval_function Default `\"eval_design\"`. string (function) specifying skpr power evaluation function. Can also `\"eval_design_mc\"`, `\"eval_design_survival_mc\"`, `\"eval_design_custom_mc\"`. eval_args Default `list()`. list argument/value pairs specify design power evaluation parameters `eval_function`. random_seed Default `123`. random seed used generate evaluate design. seed set right design generation. iterate_seed Default `FALSE`. iterate random seed new design. Set `TRUE` add variability design generation process. plot_results Default `TRUE`. Whether print plot power curves addition data frame results. Requires `ggplot2`. auto_scale Default `TRUE`. Whether automatically scale y-axis 0 1. x_breaks Default `NULL`, automaticly generated ggplot2. y_breaks Default `seq(0,1,=0.1)`. Y-axis breaks. ggplot_elements Default `list()`. Extra `ggplot2` elements customize plot, passed elements list.","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/calculate_power_curves.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Power Curves — calculate_power_curves","text":"data.frame power values design generation information.","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/calculate_power_curves.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate Power Curves — calculate_power_curves","text":"","code":"if(skpr:::run_documentation()) { cand_set = expand.grid(brew_temp = c(80, 85, 90),                       altitude = c(0, 2000, 4000),                       bean_sun = c(\"low\", \"partial\", \"high\")) #Plot power for a linear model with all interactions calculate_power_curves(trials=seq(10,60,by=5),                       candidateset = cand_set,                       model = ~.*.,                       alpha = 0.05,                       effectsize = 1,                       eval_function = \"eval_design\") |>  head(30)  }  #>              parameter            type     power trials effectsize random_seed #> 18         (Intercept)    effect.power 0.3297088     15          1         123 #> 19           brew_temp    effect.power 0.3297088     15          1         123 #> 20            altitude    effect.power 0.3297088     15          1         123 #> 21            bean_sun    effect.power 0.1599775     15          1         123 #> 22  brew_temp:altitude    effect.power 0.3248373     15          1         123 #> 23  brew_temp:bean_sun    effect.power 0.1615894     15          1         123 #> 24   altitude:bean_sun    effect.power 0.1599775     15          1         123 #> 25         (Intercept) parameter.power 0.3297088     15          1         123 #> 26           brew_temp parameter.power 0.3297088     15          1         123 #> 27            altitude parameter.power 0.3297088     15          1         123 #> 28           bean_sun1 parameter.power 0.1904301     15          1         123 #> 29           bean_sun2 parameter.power 0.1884952     15          1         123 #> 30  brew_temp:altitude parameter.power 0.3248373     15          1         123 #> 31 brew_temp:bean_sun1 parameter.power 0.1904301     15          1         123 #> 32 brew_temp:bean_sun2 parameter.power 0.1904301     15          1         123 #> 33  altitude:bean_sun1 parameter.power 0.1884952     15          1         123 #> 34  altitude:bean_sun2 parameter.power 0.1904301     15          1         123 #> 35         (Intercept)    effect.power 0.4856389     20          1         123 #> 36           brew_temp    effect.power 0.4856389     20          1         123 #> 37            altitude    effect.power 0.4856389     20          1         123 #> 38            bean_sun    effect.power 0.2447062     20          1         123 #> 39  brew_temp:altitude    effect.power 0.4856389     20          1         123 #> 40  brew_temp:bean_sun    effect.power 0.2447062     20          1         123 #> 41   altitude:bean_sun    effect.power 0.2583789     20          1         123 #> 42         (Intercept) parameter.power 0.4856389     20          1         123 #> 43           brew_temp parameter.power 0.4856389     20          1         123 #> 44            altitude parameter.power 0.4856389     20          1         123 #> 45           bean_sun1 parameter.power 0.2615680     20          1         123 #> 46           bean_sun2 parameter.power 0.2883561     20          1         123 #> 47  brew_temp:altitude parameter.power 0.4856389     20          1         123 #> Power curve generation captured the following warning/error messages: #> Function   | Type | N | Message #> Evaluation | Warn | 1 | Message: 'skpr: NA indicates not enough degrees of freedom to estimate power for those terms.' if(skpr:::run_documentation()) { #Add multiple effect sizes calculate_power_curves(trials=seq(10,60,by=1),                       candidateset = cand_set,                       model = ~.*.,                       alpha = 0.05,                       effectsize = c(1,2),                       eval_function = \"eval_design\") |>  head(30) }  #>              parameter            type      power trials effectsize random_seed #> 18         (Intercept)    effect.power 0.09280916     11          1         123 #> 19           brew_temp    effect.power 0.09280916     11          1         123 #> 20            altitude    effect.power 0.09280916     11          1         123 #> 21            bean_sun    effect.power 0.06447520     11          1         123 #> 22  brew_temp:altitude    effect.power 0.09280916     11          1         123 #> 23  brew_temp:bean_sun    effect.power 0.06447520     11          1         123 #> 24   altitude:bean_sun    effect.power 0.06447520     11          1         123 #> 25         (Intercept) parameter.power 0.09280916     11          1         123 #> 26           brew_temp parameter.power 0.09280916     11          1         123 #> 27            altitude parameter.power 0.09280916     11          1         123 #> 28           bean_sun1 parameter.power 0.06757424     11          1         123 #> 29           bean_sun2 parameter.power 0.07717846     11          1         123 #> 30  brew_temp:altitude parameter.power 0.09280916     11          1         123 #> 31 brew_temp:bean_sun1 parameter.power 0.06757424     11          1         123 #> 32 brew_temp:bean_sun2 parameter.power 0.07717846     11          1         123 #> 33  altitude:bean_sun1 parameter.power 0.06757424     11          1         123 #> 34  altitude:bean_sun2 parameter.power 0.07717846     11          1         123 #> 35         (Intercept)    effect.power 0.17925539     12          1         123 #> 36           brew_temp    effect.power 0.17925539     12          1         123 #> 37            altitude    effect.power 0.17925539     12          1         123 #> 38            bean_sun    effect.power 0.09633205     12          1         123 #> 39  brew_temp:altitude    effect.power 0.17925539     12          1         123 #> 40  brew_temp:bean_sun    effect.power 0.09633205     12          1         123 #> 41   altitude:bean_sun    effect.power 0.09633205     12          1         123 #> 42         (Intercept) parameter.power 0.17925539     12          1         123 #> 43           brew_temp parameter.power 0.17925539     12          1         123 #> 44            altitude parameter.power 0.17925539     12          1         123 #> 45           bean_sun1 parameter.power 0.11698959     12          1         123 #> 46           bean_sun2 parameter.power 0.11698959     12          1         123 #> 47  brew_temp:altitude parameter.power 0.17925539     12          1         123 #> Power curve generation captured the following warning/error messages: #> Function   | Type | N | Message #> Evaluation | Warn | 2 | Message: 'skpr: NA indicates not enough degrees of freedom to estimate power for those terms.' if(skpr:::run_documentation()) { #Generate power curve for a binomial model calculate_power_curves(trials=seq(50,150,by=10),                       candidateset = cand_set,                       model = ~.,                       effectsize = c(0.6,0.9),                       eval_function = \"eval_design_mc\",                       eval_args = list(nsim = 100, glmfamily = \"binomial\")) |>  head(30) }  #>      parameter               type power trials effectsize_low effectsize_high #> 1  (Intercept)    effect.power.mc  0.84     50            0.6             0.9 #> 2    brew_temp    effect.power.mc  0.57     50            0.6             0.9 #> 3     altitude    effect.power.mc  0.72     50            0.6             0.9 #> 4     bean_sun    effect.power.mc  0.21     50            0.6             0.9 #> 5  (Intercept) parameter.power.mc  0.84     50            0.6             0.9 #> 6    brew_temp parameter.power.mc  0.57     50            0.6             0.9 #> 7     altitude parameter.power.mc  0.72     50            0.6             0.9 #> 8    bean_sun1 parameter.power.mc  0.19     50            0.6             0.9 #> 9    bean_sun2 parameter.power.mc  0.36     50            0.6             0.9 #> 10 (Intercept)    effect.power.mc  0.93     60            0.6             0.9 #> 11   brew_temp    effect.power.mc  0.74     60            0.6             0.9 #> 12    altitude    effect.power.mc  0.73     60            0.6             0.9 #> 13    bean_sun    effect.power.mc  0.41     60            0.6             0.9 #> 14 (Intercept) parameter.power.mc  0.93     60            0.6             0.9 #> 15   brew_temp parameter.power.mc  0.74     60            0.6             0.9 #> 16    altitude parameter.power.mc  0.73     60            0.6             0.9 #> 17   bean_sun1 parameter.power.mc  0.36     60            0.6             0.9 #> 18   bean_sun2 parameter.power.mc  0.42     60            0.6             0.9 #> 19 (Intercept)    effect.power.mc  0.98     70            0.6             0.9 #> 20   brew_temp    effect.power.mc  0.83     70            0.6             0.9 #> 21    altitude    effect.power.mc  0.84     70            0.6             0.9 #> 22    bean_sun    effect.power.mc  0.44     70            0.6             0.9 #> 23 (Intercept) parameter.power.mc  0.98     70            0.6             0.9 #> 24   brew_temp parameter.power.mc  0.83     70            0.6             0.9 #> 25    altitude parameter.power.mc  0.84     70            0.6             0.9 #> 26   bean_sun1 parameter.power.mc  0.41     70            0.6             0.9 #> 27   bean_sun2 parameter.power.mc  0.54     70            0.6             0.9 #> 28 (Intercept)    effect.power.mc  1.00     80            0.6             0.9 #> 29   brew_temp    effect.power.mc  0.92     80            0.6             0.9 #> 30    altitude    effect.power.mc  0.86     80            0.6             0.9 #>    random_seed #> 1          123 #> 2          123 #> 3          123 #> 4          123 #> 5          123 #> 6          123 #> 7          123 #> 8          123 #> 9          123 #> 10         123 #> 11         123 #> 12         123 #> 13         123 #> 14         123 #> 15         123 #> 16         123 #> 17         123 #> 18         123 #> 19         123 #> 20         123 #> 21         123 #> 22         123 #> 23         123 #> 24         123 #> 25         123 #> 26         123 #> 27         123 #> 28         123 #> 29         123 #> 30         123 #> Power curve generation captured the following warning/error messages: #> Function   | Type | N | Message #> Evaluation | Warn | 1 | Message: 'skpr: Partial or complete separation likely detected in the binomial Monte Carlo simulation. Increase the number of runs in the design or decrease the number of model parameters to improve power.' if(skpr:::run_documentation()) { #Generate power curve for a binomial model and multiple effect sizes calculate_power_curves(trials=seq(50,150,by=10),                       candidateset = cand_set,                       model = ~.,                       effectsize = list(c(0.5,0.9),c(0.6,0.9)),                       eval_function = \"eval_design_mc\",                       eval_args = list(nsim = 100, glmfamily = \"binomial\")) |>  head(30) }  #>      parameter               type power trials effectsize_low effectsize_high #> 1  (Intercept)    effect.power.mc  0.80     50            0.5             0.9 #> 2    brew_temp    effect.power.mc  0.78     50            0.5             0.9 #> 3     altitude    effect.power.mc  0.81     50            0.5             0.9 #> 4     bean_sun    effect.power.mc  0.35     50            0.5             0.9 #> 5  (Intercept) parameter.power.mc  0.80     50            0.5             0.9 #> 6    brew_temp parameter.power.mc  0.78     50            0.5             0.9 #> 7     altitude parameter.power.mc  0.81     50            0.5             0.9 #> 8    bean_sun1 parameter.power.mc  0.37     50            0.5             0.9 #> 9    bean_sun2 parameter.power.mc  0.47     50            0.5             0.9 #> 10 (Intercept)    effect.power.mc  0.80     60            0.5             0.9 #> 11   brew_temp    effect.power.mc  0.89     60            0.5             0.9 #> 12    altitude    effect.power.mc  0.87     60            0.5             0.9 #> 13    bean_sun    effect.power.mc  0.46     60            0.5             0.9 #> 14 (Intercept) parameter.power.mc  0.80     60            0.5             0.9 #> 15   brew_temp parameter.power.mc  0.89     60            0.5             0.9 #> 16    altitude parameter.power.mc  0.87     60            0.5             0.9 #> 17   bean_sun1 parameter.power.mc  0.54     60            0.5             0.9 #> 18   bean_sun2 parameter.power.mc  0.51     60            0.5             0.9 #> 19 (Intercept)    effect.power.mc  0.91     70            0.5             0.9 #> 20   brew_temp    effect.power.mc  0.90     70            0.5             0.9 #> 21    altitude    effect.power.mc  0.94     70            0.5             0.9 #> 22    bean_sun    effect.power.mc  0.70     70            0.5             0.9 #> 23 (Intercept) parameter.power.mc  0.91     70            0.5             0.9 #> 24   brew_temp parameter.power.mc  0.90     70            0.5             0.9 #> 25    altitude parameter.power.mc  0.94     70            0.5             0.9 #> 26   bean_sun1 parameter.power.mc  0.62     70            0.5             0.9 #> 27   bean_sun2 parameter.power.mc  0.74     70            0.5             0.9 #> 28 (Intercept)    effect.power.mc  0.97     80            0.5             0.9 #> 29   brew_temp    effect.power.mc  0.97     80            0.5             0.9 #> 30    altitude    effect.power.mc  0.99     80            0.5             0.9 #>    random_seed #> 1          123 #> 2          123 #> 3          123 #> 4          123 #> 5          123 #> 6          123 #> 7          123 #> 8          123 #> 9          123 #> 10         123 #> 11         123 #> 12         123 #> 13         123 #> 14         123 #> 15         123 #> 16         123 #> 17         123 #> 18         123 #> 19         123 #> 20         123 #> 21         123 #> 22         123 #> 23         123 #> 24         123 #> 25         123 #> 26         123 #> 27         123 #> 28         123 #> 29         123 #> 30         123 #> Power curve generation captured the following warning/error messages: #> Function   | Type | N | Message #> Evaluation | Warn | 2 | Message: 'skpr: Partial or complete separation likely detected in the binomial Monte Carlo simulation. Increase the number of runs in the design or decrease the number of model parameters to improve power.'"},{"path":"https://tylermorganwall.github.io/skpr/reference/calculate_split_columns.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Split Plot Columns — calculate_split_columns","title":"Calculate Split Plot Columns — calculate_split_columns","text":"Calculates columns correspond layers randomization restriction","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/calculate_split_columns.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Split Plot Columns — calculate_split_columns","text":"","code":"calculate_split_columns(run_matrix_processed, blockgroups, blockstructure)"},{"path":"https://tylermorganwall.github.io/skpr/reference/calculate_split_columns.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Split Plot Columns — calculate_split_columns","text":"run_matrix_processed design","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/calculate_split_columns.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Split Plot Columns — calculate_split_columns","text":"Vector numbers indicating split plot layers","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/calculate_v_from_blocks.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate V from Blocks — calculate_v_from_blocks","title":"Calculate V from Blocks — calculate_v_from_blocks","text":"Calculates V matrix block structure","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/calculate_v_from_blocks.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate V from Blocks — calculate_v_from_blocks","text":"","code":"calculate_v_from_blocks(   nrow_design,   blockgroups,   blockstructure,   varianceratios )"},{"path":"https://tylermorganwall.github.io/skpr/reference/calculate_v_from_blocks.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate V from Blocks — calculate_v_from_blocks","text":"nrow_design number runs design blockgroups List indicating size block layer blockstructure Matrix indicating block structure rownames","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/calculate_v_from_blocks.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate V from Blocks — calculate_v_from_blocks","text":"Variance-Covariance Matrix","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/calculatepower.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Power — calculatepower","title":"Calculate Power — calculatepower","text":"Calculates power model given non-centrality parameter","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/calculatepower.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Power — calculatepower","text":"","code":"calculatepower(X, L, lambda, alpha, degrees_of_freedom)"},{"path":"https://tylermorganwall.github.io/skpr/reference/calculatepower.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Power — calculatepower","text":"X model matrix L parameter matrix/vector lambda non-centrality parameter F test alpha specified type-error degrees_of_freedom number degrees freedom.","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/calculatepower.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Power — calculatepower","text":"power given parameter L, given ","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/check_for_suggest_packages.html","id":null,"dir":"Reference","previous_headings":"","what":"check_for_suggest_packages — check_for_suggest_packages","title":"check_for_suggest_packages — check_for_suggest_packages","text":"checks suggests","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/check_for_suggest_packages.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"check_for_suggest_packages — check_for_suggest_packages","text":"","code":"check_for_suggest_packages(packages)"},{"path":"https://tylermorganwall.github.io/skpr/reference/check_for_suggest_packages.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"check_for_suggest_packages — check_for_suggest_packages","text":"none","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/check_model_validity.html","id":null,"dir":"Reference","previous_headings":"","what":"Check Model Formula Validity — check_model_validity","title":"Check Model Formula Validity — check_model_validity","text":"Check Model Formula Validity","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/check_model_validity.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check Model Formula Validity — check_model_validity","text":"","code":"check_model_validity(model)"},{"path":"https://tylermorganwall.github.io/skpr/reference/constructRunMatrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct Run Matrix given rows — constructRunMatrix","title":"Construct Run Matrix given rows — constructRunMatrix","text":"Returns number levels prior parameter","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/constructRunMatrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct Run Matrix given rows — constructRunMatrix","text":"","code":"constructRunMatrix(rowIndices, candidateList, augment = NULL)"},{"path":"https://tylermorganwall.github.io/skpr/reference/constructRunMatrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Construct Run Matrix given rows — constructRunMatrix","text":"Returns vector consisting number levels preceeding parameter (including intercept)","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/contr.simplex.html","id":null,"dir":"Reference","previous_headings":"","what":"Orthonormal Contrast Generator — contr.simplex","title":"Orthonormal Contrast Generator — contr.simplex","text":"Generates orthonormal (orthogonal normalized) contrasts. row vertex N-dimensional simplex. exception contrasts 2-level case, return 1 -1.","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/contr.simplex.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Orthonormal Contrast Generator — contr.simplex","text":"","code":"contr.simplex(n, size = NULL)"},{"path":"https://tylermorganwall.github.io/skpr/reference/contr.simplex.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Orthonormal Contrast Generator — contr.simplex","text":"n number levels catagorical variable. factor character vector, `n` `length(n)` size Default `1`. length simplex vector.","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/contr.simplex.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Orthonormal Contrast Generator — contr.simplex","text":"matrix Orthonormal contrasts.","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/contr.simplex.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Orthonormal Contrast Generator — contr.simplex","text":"","code":"contr.simplex(4) #>            [,1]       [,2]      [,3] #> [1,]  1.7320508  0.0000000  0.000000 #> [2,] -0.5773503  1.6329932  0.000000 #> [3,] -0.5773503 -0.8164966  1.414214 #> [4,] -0.5773503 -0.8164966 -1.414214"},{"path":"https://tylermorganwall.github.io/skpr/reference/convert_blockcolumn_rownames.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert Block Column to Rownames — convert_blockcolumn_rownames","title":"Convert Block Column to Rownames — convert_blockcolumn_rownames","text":"Detect externally generated blocking columns convert rownames","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/convert_blockcolumn_rownames.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert Block Column to Rownames — convert_blockcolumn_rownames","text":"","code":"convert_blockcolumn_rownames(   RunMatrix,   blocking,   varianceratios,   verbose = FALSE )"},{"path":"https://tylermorganwall.github.io/skpr/reference/convert_blockcolumn_rownames.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert Block Column to Rownames — convert_blockcolumn_rownames","text":"RunMatrix run matrix blocking Whether random effects included. varianceratios vector variance ratios level restricted randomization","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/convert_blockcolumn_rownames.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert Block Column to Rownames — convert_blockcolumn_rownames","text":"Row-name encoded blocked run matrix","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/convert_model_dots.html","id":null,"dir":"Reference","previous_headings":"","what":"Converts dot operator to terms — convert_model_dots","title":"Converts dot operator to terms — convert_model_dots","text":"Converts dot operator `.` formula linear terms model. Includes interactions (e.g. .*.)","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/convert_model_dots.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Converts dot operator to terms — convert_model_dots","text":"","code":"convert_model_dots(design, model, splitplotdesign = NULL)"},{"path":"https://tylermorganwall.github.io/skpr/reference/convert_model_dots.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Converts dot operator to terms — convert_model_dots","text":"design design model Base model splitplotdesign split plot design data.frame","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/convert_model_dots.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Converts dot operator to terms — convert_model_dots","text":"New model dot operator replaced","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/convert_rownames_to_covariance.html","id":null,"dir":"Reference","previous_headings":"","what":"Converts dot operator to terms — convert_rownames_to_covariance","title":"Converts dot operator to terms — convert_rownames_to_covariance","text":"Converts row names variance-covariance matrix (using user-supplied variance ratio)","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/convert_rownames_to_covariance.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Converts dot operator to terms — convert_rownames_to_covariance","text":"","code":"convert_rownames_to_covariance(   run_matrix_processed,   varianceratios,   user_specified_varianceratio )"},{"path":"https://tylermorganwall.github.io/skpr/reference/convert_rownames_to_covariance.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Converts dot operator to terms — convert_rownames_to_covariance","text":"run_matrix_processed design","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/convert_rownames_to_covariance.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Converts dot operator to terms — convert_rownames_to_covariance","text":"Variance-covariance matrix V","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/disallowed_combinations.html","id":null,"dir":"Reference","previous_headings":"","what":"Detect and list disallowed combinations in candidate set — disallowed_combinations","title":"Detect and list disallowed combinations in candidate set — disallowed_combinations","text":"Detects list disallowed combinations candidate set","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/disallowed_combinations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Detect and list disallowed combinations in candidate set — disallowed_combinations","text":"","code":"disallowed_combinations(candidateset)"},{"path":"https://tylermorganwall.github.io/skpr/reference/disallowed_combinations.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Detect and list disallowed combinations in candidate set — disallowed_combinations","text":"candidateset Block list","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/disallowed_combinations.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Detect and list disallowed combinations in candidate set — disallowed_combinations","text":"Returns list disallowed combinations","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/effectpower.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Effect Power — effectpower","title":"Calculate Effect Power — effectpower","text":"Calculates effect power given anticipated coefficients type-error","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/effectpower.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Effect Power — effectpower","text":"","code":"effectpower(   RunMatrix,   levelvector,   anticoef,   alpha,   vinv = NULL,   degrees = NULL )"},{"path":"https://tylermorganwall.github.io/skpr/reference/effectpower.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Effect Power — effectpower","text":"RunMatrix model matrix levelvector number levels parameter (1st always intercept) anticoef anticipated coefficients alpha specified type-error vinv V inverse matrix degrees Degrees freedom","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/effectpower.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Effect Power — effectpower","text":"effect power parameters","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/effectpowermc.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit Anova for Effect Power Calculation in Monte Carlo — effectpowermc","title":"Fit Anova for Effect Power Calculation in Monte Carlo — effectpowermc","text":"Calculates p-values effect power calculation Monte Carlo","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/effectpowermc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit Anova for Effect Power Calculation in Monte Carlo — effectpowermc","text":"","code":"effectpowermc(   fit,   type = \"III\",   test = \"Pr(>Chisq)\",   model_formula = NULL,   firth = FALSE,   glmfamily = \"gaussian\",   effect_terms = NULL,   RunMatrixReduced = NULL,   method = NULL,   contrastslist = contrastslist,   effect_anova = FALSE,   ... )"},{"path":"https://tylermorganwall.github.io/skpr/reference/effectpowermc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit Anova for Effect Power Calculation in Monte Carlo — effectpowermc","text":"fit Fit regression type Default `III` test Default `Pr(>Chisq)`. ... Additional arguments pass car::Anova","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/effectpowermc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit Anova for Effect Power Calculation in Monte Carlo — effectpowermc","text":"p-values","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/eval_design.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Power of an Experimental Design — eval_design","title":"Calculate Power of an Experimental Design — eval_design","text":"Evaluates power experimental design, normal response variables, given design's run matrix statistical model fit data. Returns data frame parameter effect powers. Designs can consist continuous categorical factors. default, eval_design assumes signal--noise ratio 2, can changed effectsize anticoef parameters.","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/eval_design.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Power of an Experimental Design — eval_design","text":"","code":"eval_design(   design,   model = NULL,   alpha = 0.05,   blocking = NULL,   anticoef = NULL,   effectsize = 2,   varianceratios = NULL,   contrasts = contr.sum,   conservative = FALSE,   reorder_factors = FALSE,   detailedoutput = FALSE,   advancedoptions = NULL,   ... )"},{"path":"https://tylermorganwall.github.io/skpr/reference/eval_design.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Power of an Experimental Design — eval_design","text":"design experimental design. Internally, eval_design rescales numeric column range [-1, 1], need scaling manually. model model used evaluating design. missing design generated skpr, generating model used. can subset model used generate design, include higher order effects original design generation. include factors present experimental design. alpha Default `0.05`. specified type-error. blocking Default `NULL`. `TRUE`, eval_design look rownames (blocking columns) determine blocking structure. Default FALSE. anticoef anticipated coefficients calculating power. missing, coefficients automatically generated based effectsize argument. effectsize Default `2`. signal--noise ratio. continuous factors, specifies difference response highest lowest levels factor (-1 +1 eval_design normalizes input data), assuming root mean square error 1. specify anticoef, anticipated coefficients half effectsize. specify anticoef, effectsize ignored. varianceratios Default `NULL`. ratio whole plot variance run--run variance. specified design generation, default 1. designs one subplot ratio can vector specifying variance ratio subplot (comparing run--run variance). Otherwise, use single value strata. contrasts Default contr.sum. function use encode categorical factors model matrix. user specified contrasts categorical factor using contrasts function, used. Otherwise, skpr use `contr.sum`. conservative Specifies whether default method generating anticipated coefficents conservative . `TRUE` give conservative estimate power setting one (multiple equally low) level categorical factor's anticipated coefficients zero. Default `FALSE`. reorder_factors Default `FALSE`. `TRUE`, levels reordered generate conservative calculation effect power. function searches possible reference levels given factor chooses one results lowest effect power. reordering presenting output `detailedoutput = TRUE`. detailedoutput `TRUE“, return additional information evaluation results. Default FALSE. advancedoptions Default `NULL`. named list parameters specify additional attributes calculate. Options: `aliaspower` gives degree Alias matrix calculated. ... Additional arguments.","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/eval_design.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Power of an Experimental Design — eval_design","text":"data frame parameters model, type power analysis, power. Several design diagnostics stored attributes data frame. particular, modelmatrix attribute contains model matrix used power evaluation. especially useful want specify anticipated coefficients use power evaluation. model matrix provides order model coefficients, well encoding used categorical factors.","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/eval_design.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate Power of an Experimental Design — eval_design","text":"function evaluates power experimental designs. design blocking restrictions randomization, model assumed : \\(y = X \\beta + \\epsilon\\). design split-plot design, model follows: \\(y = X \\beta + Z b\\)+ \\(\\epsilon\\)ij, , \\(y\\) vector experimental responses, \\(X\\) model matrix, \\(\\beta\\) vector model coefficients, \\(Z_{}\\) blocking indicator, \\(b_{}\\) random variable associated \\(\\)th block, \\(\\epsilon\\) random variable normally distributed zero mean unit variance (root-mean-square error 1.0). eval_design calculates parameter power well effect power, defined follows: 1) Parameter power probability rejecting hypothesis \\(H_0 : \\beta_i = 0\\), \\(\\beta_i\\) single parameter model 2) Effect power probability rejecting hypothesis \\(H_0 : \\beta_{1} = \\beta_{2} = ... = \\beta_{n} 0\\) \\(n\\) coefficients categorical factor. two power types equivalent continuous factors two-level categorical factors, differ categorical factors three levels. split-plot designs, degrees freedom allocated term according algorithm given \"Mixed-Effects Models S S-PLUS\" (Pinheiro Bates, pp. 91). using conservative = TRUE, eval_design first evaluates power default (given) coefficients. , multi-level categorical, sets coefficients zero except level produced lowest power, re-evaluates power modified set anticipated coefficients. two equal power values multi-level categorical, two lowest equal terms given opposite sign anticipated coefficients rest (categorical factor) set zero.","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/eval_design.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate Power of an Experimental Design — eval_design","text":"","code":"#Generating a simple 2x3 factorial to feed into our optimal design generation #of an 11-run design. factorial = expand.grid(A = c(1, -1), B = c(1, -1), C = c(1, -1))  optdesign = gen_design(candidateset = factorial,                       model= ~A + B + C, trials = 11, optimality = \"D\", repeats = 100)  #Now evaluating that design (with default anticipated coefficients and a effectsize of 2): eval_design(design = optdesign, model= ~A + B + C, alpha = 0.2) #>     parameter            type     power #> 1 (Intercept)    effect.power 0.9622638 #> 2           A    effect.power 0.9622638 #> 3           B    effect.power 0.9622638 #> 4           C    effect.power 0.9622638 #> 5 (Intercept) parameter.power 0.9622638 #> 6           A parameter.power 0.9622638 #> 7           B parameter.power 0.9622638 #> 8           C parameter.power 0.9622638 #> ============Evaluation Info============ #> • Alpha = 0.2 • Trials = 11 • Blocked = FALSE  #> • Evaluating Model = ~A + B + C  #> • Anticipated Coefficients = c(1, 1, 1, 1)  #> • Contrasts = `contr.sum`  #> • Parameter Analysis Method = `lm(...)`  #> • Effect Analysis Method = `car::Anova(fit, type = \"III\")`   #Evaluating a subset of the design (which changes the power due to a different number of #degrees of freedom) eval_design(design = optdesign, model= ~A + C, alpha = 0.2) #>     parameter            type     power #> 1 (Intercept)    effect.power 0.9659328 #> 2           A    effect.power 0.9659328 #> 3           C    effect.power 0.9659328 #> 4 (Intercept) parameter.power 0.9659328 #> 5           A parameter.power 0.9659328 #> 6           C parameter.power 0.9659328 #> ============Evaluation Info============ #> • Alpha = 0.2 • Trials = 11 • Blocked = FALSE  #> • Evaluating Model = ~A + C  #> • Anticipated Coefficients = c(1, 1, 1)  #> • Contrasts = `contr.sum`  #> • Parameter Analysis Method = `lm(...)`  #> • Effect Analysis Method = `car::Anova(fit, type = \"III\")`   #We do not have to input the model if it's the same as the model used #During design generation. Here, we also use the default value for alpha (`0.05`) eval_design(optdesign) #>     parameter            type     power #> 1 (Intercept)    effect.power 0.7991116 #> 2           A    effect.power 0.7991116 #> 3           B    effect.power 0.7991116 #> 4           C    effect.power 0.7991116 #> 5 (Intercept) parameter.power 0.7991116 #> 6           A parameter.power 0.7991116 #> 7           B parameter.power 0.7991116 #> 8           C parameter.power 0.7991116 #> ============Evaluation Info============ #> • Alpha = 0.05 • Trials = 11 • Blocked = FALSE  #> • Evaluating Model = ~A + B + C  #> • Anticipated Coefficients = c(1, 1, 1, 1)  #> • Contrasts = `contr.sum`  #> • Parameter Analysis Method = `lm(...)`  #> • Effect Analysis Method = `car::Anova(fit, type = \"III\")`   #Halving the signal-to-noise ratio by setting a different effectsize (default is 2): eval_design(design = optdesign, model= ~A + B + C, alpha = 0.2, effectsize = 1) #>     parameter            type     power #> 1 (Intercept)    effect.power 0.6021367 #> 2           A    effect.power 0.6021367 #> 3           B    effect.power 0.6021367 #> 4           C    effect.power 0.6021367 #> 5 (Intercept) parameter.power 0.6021367 #> 6           A parameter.power 0.6021367 #> 7           B parameter.power 0.6021367 #> 8           C parameter.power 0.6021367 #> ============Evaluation Info============ #> • Alpha = 0.2 • Trials = 11 • Blocked = FALSE  #> • Evaluating Model = ~A + B + C  #> • Anticipated Coefficients = c(0.500, 0.500, 0.500, 0.500)  #> • Contrasts = `contr.sum`  #> • Parameter Analysis Method = `lm(...)`  #> • Effect Analysis Method = `car::Anova(fit, type = \"III\")`   #With 3+ level categorical factors, the choice of anticipated coefficients directly changes the #final power calculation. For the most conservative power calculation, that involves #setting all anticipated coefficients in a factor to zero except for one. We can specify this #option with the \"conservative\" argument.  factorialcoffee = expand.grid(cost = c(1, 2),                               type = as.factor(c(\"Kona\", \"Colombian\", \"Ethiopian\", \"Sumatra\")),                               size = as.factor(c(\"Short\", \"Grande\", \"Venti\")))  designcoffee = gen_design(factorialcoffee,                          ~cost + size + type, trials = 29, optimality = \"D\", repeats = 100)  #Evaluate the design, with default anticipated coefficients (conservative is FALSE by default). eval_design(designcoffee) #>      parameter            type     power #> 1  (Intercept)    effect.power 0.9990689 #> 2         cost    effect.power 0.9991530 #> 3         size    effect.power 0.9522717 #> 4         type    effect.power 0.9907584 #> 5  (Intercept) parameter.power 0.9990689 #> 6         cost parameter.power 0.9991530 #> 7        size1 parameter.power 0.9443775 #> 8        size2 parameter.power 0.9443775 #> 9        type1 parameter.power 0.8339422 #> 10       type2 parameter.power 0.8339422 #> 11       type3 parameter.power 0.8339422 #> ============Evaluation Info============= #> • Alpha = 0.05 • Trials = 29 • Blocked = FALSE  #> • Evaluating Model = ~cost + size + type  #> • Anticipated Coefficients = c(1, 1, 1, -1, 1, -1, 1)  #> • Contrasts = `contr.sum`  #> • Parameter Analysis Method = `lm(...)`  #> • Effect Analysis Method = `car::Anova(fit, type = \"III\")`   #Evaluate the design, with conservative anticipated coefficients: eval_design(designcoffee, conservative = TRUE) #>      parameter            type     power #> 1  (Intercept)    effect.power 0.9990689 #> 2         cost    effect.power 0.9991530 #> 3         size    effect.power 0.9522717 #> 4         type    effect.power 0.8300151 #> 5  (Intercept) parameter.power 0.9990689 #> 6         cost parameter.power 0.9991530 #> 7        size1 parameter.power 0.0500000 #> 8        size2 parameter.power 0.9443775 #> 9        type1 parameter.power 0.0500000 #> 10       type2 parameter.power 0.8339422 #> 11       type3 parameter.power 0.8339422 #> ============Evaluation Info============= #> • Alpha = 0.05 • Trials = 29 • Blocked = FALSE  #> • Evaluating Model = ~cost + size + type  #> • Anticipated Coefficients = c(1, 1, 0, 1, 0, 1, -1)  #> • Contrasts = `contr.sum`  #> • Parameter Analysis Method = `lm(...)`  #> • Effect Analysis Method = `car::Anova(fit, type = \"III\")`   #which is the same as the following, but now explicitly entering the coefficients: eval_design(designcoffee, anticoef = c(1, 1, 1, 0, 0, 1, 0)) #>      parameter            type     power #> 1  (Intercept)    effect.power 0.9990689 #> 2         cost    effect.power 0.9991530 #> 3         size    effect.power 0.9654778 #> 4         type    effect.power 0.8478953 #> 5  (Intercept) parameter.power 0.9990689 #> 6         cost parameter.power 0.9991530 #> 7        size1 parameter.power 0.9443775 #> 8        size2 parameter.power 0.0500000 #> 9        type1 parameter.power 0.0500000 #> 10       type2 parameter.power 0.8339422 #> 11       type3 parameter.power 0.0500000 #> ============Evaluation Info============= #> • Alpha = 0.05 • Trials = 29 • Blocked = FALSE  #> • Evaluating Model = ~cost + size + type  #> • Anticipated Coefficients = c(1, 1, 1, 0, 0, 1, 0)  #> • Contrasts = `contr.sum`  #> • Parameter Analysis Method = `lm(...)`  #> • Effect Analysis Method = `car::Anova(fit, type = \"III\")`   #You can also evaluate the design with higher order effects, even if they were not #used in design generation: eval_design(designcoffee, model = ~cost + size + type + cost * type) #>      parameter            type     power #> 1  (Intercept)    effect.power 0.9989226 #> 2         cost    effect.power 0.9989944 #> 3         size    effect.power 0.9476843 #> 4         type    effect.power 0.9879203 #> 5    cost:type    effect.power 0.9859502 #> 6  (Intercept) parameter.power 0.9989226 #> 7         cost parameter.power 0.9989944 #> 8        size1 parameter.power 0.9361224 #> 9        size2 parameter.power 0.9361224 #> 10       type1 parameter.power 0.8215540 #> 11       type2 parameter.power 0.8215540 #> 12       type3 parameter.power 0.8215540 #> 13  cost:type1 parameter.power 0.8185524 #> 14  cost:type2 parameter.power 0.8185524 #> 15  cost:type3 parameter.power 0.8185524 #> ============Evaluation Info============= #> • Alpha = 0.05 • Trials = 29 • Blocked = FALSE  #> • Evaluating Model = ~cost + size + type + cost:type  #> • Anticipated Coefficients = c(1, 1, 1, -1, 1, -1, 1, 1, -1, 1)  #> • Contrasts = `contr.sum`  #> • Parameter Analysis Method = `lm(...)`  #> • Effect Analysis Method = `car::Anova(fit, type = \"III\")`    #Generating and evaluating a split plot design: splitfactorialcoffee = expand.grid(caffeine = c(1, -1),                                   cost = c(1, 2),                                   type = as.factor(c(\"Kona\", \"Colombian\", \"Ethiopian\", \"Sumatra\")),                                   size = as.factor(c(\"Short\", \"Grande\", \"Venti\")))  coffeeblockdesign = gen_design(splitfactorialcoffee, ~caffeine, trials = 12) coffeefinaldesign = gen_design(splitfactorialcoffee,                               model = ~caffeine + cost + size + type, trials = 36,                               splitplotdesign = coffeeblockdesign, blocksizes = 3)  #Evaluating design (blocking is automatically detected) eval_design(coffeefinaldesign, 0.2, blocking = TRUE) #>      parameter            type     power #> 1  (Intercept)    effect.power 0.9453423 #> 2     caffeine    effect.power 0.9448020 #> 3         cost    effect.power 0.9999931 #> 4         size    effect.power 0.9990524 #> 5         type    effect.power 0.9998370 #> 6  (Intercept) parameter.power 0.9453423 #> 7     caffeine parameter.power 0.9448020 #> 8         cost parameter.power 0.9999931 #> 9        size1 parameter.power 0.9980496 #> 10       size2 parameter.power 0.9980496 #> 11       type1 parameter.power 0.9758438 #> 12       type2 parameter.power 0.9758438 #> 13       type3 parameter.power 0.9756156 #> ============Evaluation Info============= #> • Alpha = 0.2 • Trials = 36 • Blocked = TRUE  #> • Evaluating Model = ~caffeine + cost + size + type  #> • Anticipated Coefficients = c(1, 1, 1, 1, -1, 1, -1, 1)  #> • Number of Blocks = Level 1: 12  #> • Variance Ratios  = Level 1: 1, Level 2: 1  #> • Contrasts = `contr.sum`  #> • Parameter Analysis Method = `lmerTest::lmer(...)`  #> • Effect Analysis Method = `car::Anova(fit, type = \"III\")`   #Manually turn blocking off to see completely randomized design power eval_design(coffeefinaldesign, 0.2, blocking = FALSE) #>      parameter            type     power #> 1  (Intercept)    effect.power 0.9999981 #> 2     caffeine    effect.power 0.9999978 #> 3         cost    effect.power 0.9999978 #> 4         size    effect.power 0.9991258 #> 5         type    effect.power 0.9999460 #> 6  (Intercept) parameter.power 0.9999981 #> 7     caffeine parameter.power 0.9999978 #> 8         cost parameter.power 0.9999978 #> 9        size1 parameter.power 0.9981168 #> 10       size2 parameter.power 0.9981168 #> 11       type1 parameter.power 0.9828414 #> 12       type2 parameter.power 0.9828414 #> 13       type3 parameter.power 0.9828414 #> ============Evaluation Info============= #> • Alpha = 0.2 • Trials = 36 • Blocked = FALSE  #> • Evaluating Model = ~caffeine + cost + size + type  #> • Anticipated Coefficients = c(1, 1, 1, 1, -1, 1, -1, 1)  #> • Contrasts = `contr.sum`  #> • Parameter Analysis Method = `lm(...)`  #> • Effect Analysis Method = `car::Anova(fit, type = \"III\")`   #We can also evaluate the design with a custom ratio between the whole plot error to #the run-to-run error. eval_design(coffeefinaldesign, 0.2, varianceratios = 2) #>      parameter            type     power #> 1  (Intercept)    effect.power 0.8158743 #> 2     caffeine    effect.power 0.8153089 #> 3         cost    effect.power 0.9999919 #> 4         size    effect.power 0.9990524 #> 5         type    effect.power 0.9998136 #> 6  (Intercept) parameter.power 0.8158743 #> 7     caffeine parameter.power 0.8153089 #> 8         cost parameter.power 0.9999919 #> 9        size1 parameter.power 0.9980496 #> 10       size2 parameter.power 0.9980496 #> 11       type1 parameter.power 0.9746798 #> 12       type2 parameter.power 0.9746798 #> 13       type3 parameter.power 0.9744428 #> ============Evaluation Info============= #> • Alpha = 0.2 • Trials = 36 • Blocked = TRUE  #> • Evaluating Model = ~caffeine + cost + size + type  #> • Anticipated Coefficients = c(1, 1, 1, 1, -1, 1, -1, 1)  #> • Number of Blocks = Level 1: 12  #> • Variance Ratios  = Level 1: 2  #> • Contrasts = `contr.sum`  #> • Parameter Analysis Method = `lmerTest::lmer(...)`  #> • Effect Analysis Method = `car::Anova(fit, type = \"III\")`   #If the design was generated outside of skpr and thus the row names do not have the #blocking structure encoded already, the user can add these manually. For a 12-run #design with 4 blocks, here is a vector indicated the blocks:  blockcolumn = c(1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4)  #If we wanted to add this blocking structure to the design coffeeblockdesign, we would #add a column with the format \"Block1\", \"Block2\", \"Block3\" ... and each one will be treated #as a separate blocking layer.  coffeeblockdesign$Block1 = blockcolumn  #By default, skpr will throw out the blocking columns unless the user specifies `blocking = TRUE`. eval_design(coffeeblockdesign, blocking=TRUE) #>     parameter            type     power #> 1 (Intercept)    effect.power 0.2314776 #> 2    caffeine    effect.power 0.2314776 #> 3 (Intercept) parameter.power 0.2314776 #> 4    caffeine parameter.power 0.2314776 #> ============Evaluation Info============ #> • Alpha = 0.05 • Trials = 12 • Blocked = TRUE  #> • Evaluating Model = ~caffeine  #> • Anticipated Coefficients = c(1, 1)  #> • Number of Blocks = Level 1: 4  #> • Variance Ratios  = Level 1: 1  #> • Contrasts = `contr.sum`  #> • Parameter Analysis Method = `lmerTest::lmer(...)`  #> • Effect Analysis Method = `car::Anova(fit, type = \"III\")`"},{"path":"https://tylermorganwall.github.io/skpr/reference/eval_design_custom_mc.html","id":null,"dir":"Reference","previous_headings":"","what":"Monte Carlo power evaluation for experimental designs with user-supplied libraries — eval_design_custom_mc","title":"Monte Carlo power evaluation for experimental designs with user-supplied libraries — eval_design_custom_mc","text":"Evaluates power experimental design, given run matrix statistical model fit data, using monte carlo simulation. Simulated data fit using user-supplied fitting library power estimated fraction times parameter significant. Returns data frame parameter powers.","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/eval_design_custom_mc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Monte Carlo power evaluation for experimental designs with user-supplied libraries — eval_design_custom_mc","text":"","code":"eval_design_custom_mc(   design,   model = NULL,   alpha = 0.05,   nsim,   rfunction,   fitfunction,   pvalfunction,   anticoef,   effectsize = 2,   contrasts = contr.sum,   coef_function = coef,   calceffect = FALSE,   detailedoutput = FALSE,   parameternames = NULL,   advancedoptions = NULL,   progress = TRUE,   parallel = FALSE,   parallel_pkgs = NULL,   ... )"},{"path":"https://tylermorganwall.github.io/skpr/reference/eval_design_custom_mc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Monte Carlo power evaluation for experimental designs with user-supplied libraries — eval_design_custom_mc","text":"design experimental design. Internally, eval_design_custom_mc rescales numeric column range [-1, 1]. model model used evaluating design. missing design generated skpr, generating model used. can subset model used generate design, include higher order effects original design generation. include factors present experimental design. alpha Default `0.05`. type-error. p-values less counted significant. nsim number simulations. rfunction Random number generator function. function form f(X, b), X model matrix b anticipated coefficients. fitfunction Function used fit data. form f(formula, X, contrasts) X model matrix. contrasts need specified user supplied library, argument can ignored. pvalfunction Function returns vector p-values object returned fitfunction. anticoef anticipated coefficients calculating power. missing, coefficients automatically generated based effectsize. effectsize signal--noise ratio. Default 2. gaussian model, continuous factors, specifies difference response highest lowest levels factor (+1 -1 normalization). precisely: specify anticoef, anticipated coefficients half effectsize. specify anticoef, effectsize ignored. contrasts Default contr.sum. Function used generate contrasts encoding categorical variables. user specified contrasts categorical factor using contrasts function, used. Otherwise, skpr use contr.sum. coef_function Function , applied fitfunction return object, returns estimated coefficients. calceffect Default `FALSE`. Calculates effect power Type-III Anova (using car package) using Wald test. ratio can vector specifying variance ratio subplot. Otherwise, use single value strata. work, fit returned `fitfunction` must method compatable car package. detailedoutput Default `FALSE`. `TRUE`, return additional information evaluation results. parameternames Vector parameter names coefficients correspond simply columns model matrix (e.g. coefficients MLE fit). advancedoptions Default `NULL`. Named list advanced options. `advancedoptions$anovatype` specifies Anova type car package (default type `III`), user can change type `II`). `advancedoptions$anovatest` specifies test statistic user want `Wald` test–options likelyhood-ratio `LR` F-test `F`. `advancedoptions$progressBarUpdater` function called non-parallel simulations can used update external progress bar.`advancedoptions$GUI` turns warning messages GUI. `advancedoptions$save_simulated_responses = TRUE`, dataframe attribute `simulated_responses` contains simulated responses power evaluation. `advancedoptions$ci_error_conf` set confidence level power intervals, printed `detailedoutput = TRUE`. progress Default `TRUE`. Whether include progress bar. parallel Default `FALSE`. `TRUE`, power simulation use one available cores. user wants set number cores manually, can setting `options(\"cores\")` desired number (e.g. `options(\"cores\" = parallel::detectCores())`). NOTE: installed BLAS libraries include multicore support (e.g. Intel MKL comes Microsoft R Open), turning parallel result reduced performance. parallel_pkgs vector strings listing external packages included parallel worker. ... Additional arguments.","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/eval_design_custom_mc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Monte Carlo power evaluation for experimental designs with user-supplied libraries — eval_design_custom_mc","text":"data frame consisting parameters powers. parameter estimates simulations stored 'estimates' attribute.","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/eval_design_custom_mc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Monte Carlo power evaluation for experimental designs with user-supplied libraries — eval_design_custom_mc","text":"","code":"#To demonstrate how a user can use their own libraries for Monte Carlo power generation, #We will recreate eval_design_survival_mc using the eval_design_custom_mc framework.  #To begin, first let us generate the same design and random generation function shown in the #eval_design_survival_mc examples:  basicdesign = expand.grid(a = c(-1, 1), b = c(\"a\",\"b\",\"c\")) design = gen_design(candidateset = basicdesign, model = ~a + b + a:b, trials = 100,                          optimality = \"D\", repeats = 100)  #Random number generating function  rsurvival = function(X, b) {  Y = rexp(n = nrow(X), rate = exp(-(X %*% b)))  censored = Y > 1  Y[censored] = 1  return(survival::Surv(time = Y, event = !censored, type = \"right\")) }  #We now need to tell the package how we want to fit our data, #given the formula and the model matrix X (and, if needed, the list of contrasts). #If the contrasts aren't required, \"contrastslist\" should be set to NULL. #This should return some type of fit object.  fitsurv = function(formula, X, contrastslist = NULL) {  return(survival::survreg(formula, data = X, dist = \"exponential\")) }   #We now need to tell the package how to extract the p-values from the fit object returned #from the fit function. This is how to extract the p-values from the survreg fit object:  pvalsurv = function(fit) {  return(summary(fit)$table[, 4]) }  #And now we evaluate the design, passing the fitting function and p-value extracting function #in along with the standard inputs for eval_design_mc. #This has the exact same behavior as eval_design_survival_mc for the exponential distribution. eval_design_custom_mc(design = design, model = ~a + b + a:b,                      alpha = 0.05, nsim = 100,                      fitfunction = fitsurv, pvalfunction = pvalsurv,                      rfunction = rsurvival, effectsize = 1) #>     parameter                      type power #> 1 (Intercept) custom.parameter.power.mc  0.83 #> 2           a custom.parameter.power.mc  0.77 #> 3          b1 custom.parameter.power.mc  0.27 #> 4          b2 custom.parameter.power.mc  0.64 #> 5        a:b1 custom.parameter.power.mc  0.26 #> 6        a:b2 custom.parameter.power.mc  0.54 #> ===============Evaluation Info=============== #> • Alpha = 0.05 • Trials = 100 • Blocked = FALSE  #> • Evaluating Model = ~a + b + a:b  #> • Anticipated Coefficients = c(0.500, 0.500, 0.500, -0.500, 0.500, -0.500)  #We can also use skpr's framework for parallel computation to automatically parallelize this #to speed up computation if (FALSE) eval_design_custom_mc(design = design, model = ~a + b + a:b,                          alpha = 0.05, nsim = 1000,                          fitfunction = fitsurv, pvalfunction = pvalsurv,                          rfunction = rsurvival, effectsize = 1,                          parallel = TRUE, parallel_pkgs = \"survival\")  # \\dontrun{}"},{"path":"https://tylermorganwall.github.io/skpr/reference/eval_design_mc.html","id":null,"dir":"Reference","previous_headings":"","what":"Monte Carlo Power Evaluation for Experimental Designs — eval_design_mc","title":"Monte Carlo Power Evaluation for Experimental Designs — eval_design_mc","text":"Evaluates power experimental design, given run matrix statistical model fit data, using monte carlo simulation. Simulated data fit using generalized linear model power estimated fraction times parameter significant. Returns data frame parameter powers.","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/eval_design_mc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Monte Carlo Power Evaluation for Experimental Designs — eval_design_mc","text":"","code":"eval_design_mc(   design,   model = NULL,   alpha = 0.05,   blocking = NULL,   nsim = 1000,   glmfamily = \"gaussian\",   calceffect = TRUE,   effect_anova = TRUE,   varianceratios = NULL,   rfunction = NULL,   anticoef = NULL,   firth = FALSE,   effectsize = 2,   contrasts = contr.sum,   parallel = FALSE,   adjust_alpha_inflation = FALSE,   detailedoutput = FALSE,   progress = TRUE,   advancedoptions = NULL,   ... )"},{"path":"https://tylermorganwall.github.io/skpr/reference/eval_design_mc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Monte Carlo Power Evaluation for Experimental Designs — eval_design_mc","text":"design experimental design. Internally, eval_design_mc rescales numeric column range [-1, 1]. model model used evaluating design. missing design generated skpr, generating model used. can subset model used generate design, include higher order effects original design generation. include factors present experimental design. alpha Default `0.05`. type-error. p-values less counted significant. blocking Default `NULL`. `TRUE`, eval_design_mc look rownames (blocking columns) determine blocking structure. Default FALSE. nsim Default `1000`. number Monte Carlo simulations perform. glmfamily Default `gaussian`. String indicating family distribution `glm` function (\"gaussian\", \"binomial\", \"poisson\", \"exponential\"). calceffect Default `TRUE`. Whether calculate effect power. calculation expensive parameter power, turned (needed) can greatly speed calculation time. effect_anova Default `TRUE`, whether Type-III Anova likelihood ratio test calculate effect power. `TRUE`, effect power calculated using Type-III Anova (using car package) Wald test. `FALSE`, likelihood ratio test (using reduced model effect) performed using `lmtest` package. `firth = TRUE`, set `FALSE` automatically. varianceratios Default `NULL`. ratio whole plot variance run--run variance. specified design generation, default 1. designs one subplot ratio can vector specifying variance ratio subplot (comparing run--run variance). Otherwise, use single value strata. rfunction Default `NULL`.Random number generator function response variable. function form f(X, b, delta), X model matrix, b anticipated coefficients, delta vector blocking errors. Typically something like rnorm(nrow(X), X * b + delta, 1). need specify like default behavior described . anticoef Default `NULL`.anticipated coefficients calculating power. missing, coefficients automatically generated based effectsize argument. firth Default `FALSE`. Whether apply firth correction (via `mbest` package) logistic regression. setting also automatically sets `effect_lr = TRUE`. effectsize Helper argument generate anticipated coefficients. See details info. specify anticoef, effectsize ignored. contrasts Default contr.sum. contrasts use categorical factors. user specified contrasts categorical factor using contrasts function, used. Otherwise, skpr use contr.sum. user wants set number cores manually, can setting `options(\"cores\")` desired number (e.g. `options(\"cores\" = parallel::detectCores())`). NOTE: installed BLAS libraries include multicore support (e.g. Intel MKL comes Microsoft R Open), turning parallel result reduced performance. parallel Default `FALSE`. `TRUE`, Monte Carlo power calculation use one available cores. user wants set number cores manually, can setting `options(\"cores\")` desired number (e.g. `options(\"cores\" = parallel::detectCores())`). NOTE: installed BLAS libraries include multicore support (e.g. Intel MKL comes Microsoft R Open), turning parallel result reduced performance. adjust_alpha_inflation Default `FALSE`. `TRUE`, run simulation twice: first calculate empirical distribution p-values null hypothesis find true Type-error cutoff corresponds desired Type-error rate, given effect size calculate power values. detailedoutput Default `FALSE`. `TRUE`, return additional information evaluation results. progress Default `TRUE`. Whether include progress bar. advancedoptions Default `NULL`. Named list advanced options. `advancedoptions$anovatype` specifies Anova type car package (default type `III`), user can change type `II`). `advancedoptions$anovatest` specifies test statistic user want `Wald` test–options likelyhood-ratio `LR` F-test `F`. `advancedoptions$progressBarUpdater` function called non-parallel simulations can used update external progress bar.`advancedoptions$GUI` turns warning messages GUI. `advancedoptions$save_simulated_responses = TRUE`, dataframe attribute `simulated_responses` contains simulated responses power evaluation. `advancedoptions$ci_error_conf` set confidence level power intervals, printed `detailedoutput = TRUE`. ... Additional arguments.","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/eval_design_mc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Monte Carlo Power Evaluation for Experimental Designs — eval_design_mc","text":"data frame consisting parameters powers, supplementary information stored data frame's attributes. parameter estimates simulations stored \"estimates\" attribute. \"modelmatrix\" attribute contains model matrix used power evaluation, also provides encoding used categorical factors. want specify anticipated coefficients manually, order parameters appear model matrix.","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/eval_design_mc.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Monte Carlo Power Evaluation for Experimental Designs — eval_design_mc","text":"Evaluates power design Monte Carlo simulation. Data simulated fit generalized linear model, fraction simulations parameter significant (p-value, according fit function used, less specified alpha) estimate power parameter. First, blocking = TURE, random noise blocking generated rnorm. block gets single sample Gaussian random noise, variance specified varianceratios, sample copied run block. , rfunction called generate simulated response run design, data fit using appropriate fitting function. functions used simulate data fit determined glmfamily blocking arguments follows. , X model matrix, b anticipated coefficients, d vector blocking noise (blocking = FALSE d = 0): Note exponential random generator uses \"rate\" parameter, skpr glm use mean value parameterization (= 1 / rate), hence minus sign . Also note gaussian model assumes root-mean-square error 1. Power dependent anticipated coefficients. can specify directly anticoef argument, can use effectsize argument specify effect size skpr auto-generate . can provide either length-1 length-2 vector. provide length-1 vector, anticipated coefficients half effectsize; equivalent saying linear predictor (gaussian model, mean response; binomial model, log odds ratio; exponential model, log mean value; poisson model, log expected response) changes effectsize continuous factor goes lowest level highest level. provide length-2 vector, anticipated coefficients set mean response (gaussian model, mean response; binomial model, probability; exponential model, mean response; poisson model, expected response) changes effectsize[1] effectsize[2] factor goes lowest level highest level, assuming factors inactive (x-values zero). effect length-2 effectsize depends glmfamily argument follows: glmfamily = 'gaussian', coefficients set (effectsize[2] - effectsize[1]) / 2. glmfamily = 'binomial', intercept 1/2 * log(effectsize[1] * effectsize[2] / (1 - effectsize[1]) / (1 - effectsize[2])), coefficients 1/2 * log(effectsize[2] * (1 - effectsize[1]) / (1 - effectsize[2]) / effectsize[1]). glmfamily = 'exponential' 'poisson', intercept 1 / 2 * (log(effectsize[2]) + log(effectsize[1])), coefficients 1 / 2 * (log(effectsize[2]) - log(effectsize[1])).","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/eval_design_mc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Monte Carlo Power Evaluation for Experimental Designs — eval_design_mc","text":"","code":"#We first generate a full factorial design using expand.grid: factorialcoffee = expand.grid(cost = c(-1, 1),                               type = as.factor(c(\"Kona\", \"Colombian\", \"Ethiopian\", \"Sumatra\")),                               size = as.factor(c(\"Short\", \"Grande\", \"Venti\"))) if(skpr:::run_documentation()) { #And then generate the 21-run D-optimal design using gen_design. designcoffee = gen_design(factorialcoffee,                          model = ~cost + type + size, trials = 21, optimality = \"D\") } if(skpr:::run_documentation()) { #To evaluate this design using a normal approximation, we just use eval_design #(here using the default settings for contrasts, effectsize, and the anticipated coefficients):  eval_design(design = designcoffee, model = ~cost + type + size, 0.05) } #>      parameter            type     power #> 1  (Intercept)    effect.power 0.9871086 #> 2         cost    effect.power 0.9871086 #> 3         type    effect.power 0.9239395 #> 4         size    effect.power 0.8484877 #> 5  (Intercept) parameter.power 0.9871086 #> 6         cost parameter.power 0.9871086 #> 7        type1 parameter.power 0.6652414 #> 8        type2 parameter.power 0.6652414 #> 9        type3 parameter.power 0.6652414 #> 10       size1 parameter.power 0.8434093 #> 11       size2 parameter.power 0.8434093 #> ============Evaluation Info============= #> • Alpha = 0.05 • Trials = 21 • Blocked = FALSE  #> • Evaluating Model = ~cost + type + size  #> • Anticipated Coefficients = c(1, 1, 1, -1, 1, 1, -1)  #> • Contrasts = `contr.sum`  #> • Parameter Analysis Method = `lm(...)`  #> • Effect Analysis Method = `car::Anova(fit, type = \"III\")`  if(skpr:::run_documentation()) { #To evaluate this design with a Monte Carlo method, we enter the same information #used in eval_design, with the addition of the number of simulations \"nsim\" and the distribution #family used in fitting for the glm \"glmfamily\". For gaussian, binomial, exponential, and poisson #families, a default random generating function (rfunction) will be supplied. If another glm #family is used or the default random generating function is not adequate, a custom generating #function can be supplied by the user. Like in `eval_design()`, if the model isn't entered, the #model used in generating the design will be used.  eval_design_mc(designcoffee, nsim = 100, glmfamily = \"gaussian\") } #>      parameter               type power #> 1  (Intercept)    effect.power.mc  0.98 #> 2         cost    effect.power.mc  0.99 #> 3         type    effect.power.mc  0.92 #> 4         size    effect.power.mc  0.84 #> 5  (Intercept) parameter.power.mc  0.98 #> 6         cost parameter.power.mc  0.99 #> 7        type1 parameter.power.mc  0.62 #> 8        type2 parameter.power.mc  0.62 #> 9        type3 parameter.power.mc  0.69 #> 10       size1 parameter.power.mc  0.80 #> 11       size2 parameter.power.mc  0.82 #> ============Evaluation Info============ #> • Alpha = 0.05 • Trials = 21 • Blocked = FALSE  #> • Evaluating Model = ~cost + type + size  #> • Anticipated Coefficients = c(1, 1, 1, -1, 1, 1, -1)  #> • Contrasts = `contr.sum`  #> • Parameter Analysis Method = `lm(...)`  #> • Effect Analysis Method = `car::Anova(fit, type = \"III\")`  if(skpr:::run_documentation()) { #We can also add error bars on the Monte Carlo power values by setting #`detailedoutput = TRUE` (which will print out other information as well). #We can set the confidence via the `advancedoptions` argument. eval_design_mc(designcoffee, nsim = 100, glmfamily = \"gaussian\",               detailedoutput = TRUE, advancedoptions = list(ci_error_conf  = 0.8)) } #>      parameter               type power anticoef alpha glmfamily trials nsim #> 1  (Intercept)    effect.power.mc  1.00       NA  0.05  gaussian     21  100 #> 2         cost    effect.power.mc  0.98       NA  0.05  gaussian     21  100 #> 3         type    effect.power.mc  0.97       NA  0.05  gaussian     21  100 #> 4         size    effect.power.mc  0.87       NA  0.05  gaussian     21  100 #> 5  (Intercept) parameter.power.mc  1.00        1  0.05  gaussian     21  100 #> 6         cost parameter.power.mc  0.98        1  0.05  gaussian     21  100 #> 7        type1 parameter.power.mc  0.61        1  0.05  gaussian     21  100 #> 8        type2 parameter.power.mc  0.74       -1  0.05  gaussian     21  100 #> 9        type3 parameter.power.mc  0.72        1  0.05  gaussian     21  100 #> 10       size1 parameter.power.mc  0.86        1  0.05  gaussian     21  100 #> 11       size2 parameter.power.mc  0.84       -1  0.05  gaussian     21  100 #>    blocking error_adjusted_alpha power_lcb power_ucb #> 1     FALSE                 0.05 0.9772372 1.0000000 #> 2     FALSE                 0.05 0.9476547 0.9946693 #> 3     FALSE                 0.05 0.9344142 0.9889293 #> 4     FALSE                 0.05 0.8161255 0.9120174 #> 5     FALSE                 0.05 0.9772372 1.0000000 #> 6     FALSE                 0.05 0.9476547 0.9946693 #> 7     FALSE                 0.05 0.5412640 0.6753363 #> 8     FALSE                 0.05 0.6754202 0.7970937 #> 9     FALSE                 0.05 0.6544316 0.7787205 #> 10    FALSE                 0.05 0.8049623 0.9035414 #> 11    FALSE                 0.05 0.7828449 0.8863619 #> =======================================================Evaluation Info======================================================== #> • Alpha = 0.05 • Trials = 21 • Blocked = FALSE  #> • Evaluating Model = ~cost + type + size  #> • Anticipated Coefficients = c(1, 1, 1, -1, 1, 1, -1)  #> • Contrasts = `contr.sum`  #> • Parameter Analysis Method = `lm(...)`  #> • Effect Analysis Method = `car::Anova(fit, type = \"III\")`  #> • MC Power CI Confidence = 80%  if(skpr:::run_documentation()) { #We see here we generate approximately the same parameter powers as we do #using the normal approximation in eval_design. Like eval_design, we can also change #effectsize to produce a different signal-to-noise ratio:  eval_design_mc(design = designcoffee, nsim = 100,                        glmfamily = \"gaussian\", effectsize = 1) } #>      parameter               type power #> 1  (Intercept)    effect.power.mc  0.56 #> 2         cost    effect.power.mc  0.56 #> 3         type    effect.power.mc  0.33 #> 4         size    effect.power.mc  0.32 #> 5  (Intercept) parameter.power.mc  0.56 #> 6         cost parameter.power.mc  0.56 #> 7        type1 parameter.power.mc  0.23 #> 8        type2 parameter.power.mc  0.24 #> 9        type3 parameter.power.mc  0.18 #> 10       size1 parameter.power.mc  0.36 #> 11       size2 parameter.power.mc  0.32 #> ============Evaluation Info============ #> • Alpha = 0.05 • Trials = 21 • Blocked = FALSE  #> • Evaluating Model = ~cost + type + size  #> • Anticipated Coefficients = c(0.500, 0.500, 0.500, -0.500, 0.500, 0.500, -0.500)  #> • Contrasts = `contr.sum`  #> • Parameter Analysis Method = `lm(...)`  #> • Effect Analysis Method = `car::Anova(fit, type = \"III\")`  if(skpr:::run_documentation()) { #Like eval_design, we can also evaluate the design with a different model than #the one that generated the design. eval_design_mc(design = designcoffee, model = ~cost + type, alpha = 0.05,               nsim = 100, glmfamily = \"gaussian\") } #>     parameter               type power #> 1 (Intercept)    effect.power.mc  0.99 #> 2        cost    effect.power.mc  0.97 #> 3        type    effect.power.mc  0.88 #> 4 (Intercept) parameter.power.mc  0.99 #> 5        cost parameter.power.mc  0.97 #> 6       type1 parameter.power.mc  0.74 #> 7       type2 parameter.power.mc  0.66 #> 8       type3 parameter.power.mc  0.57 #> ===========Evaluation Info============ #> • Alpha = 0.05 • Trials = 21 • Blocked = FALSE  #> • Evaluating Model = ~cost + type  #> • Anticipated Coefficients = c(1, 1, 1, -1, 1)  #> • Contrasts = `contr.sum`  #> • Parameter Analysis Method = `lm(...)`  #> • Effect Analysis Method = `car::Anova(fit, type = \"III\")`  if(skpr:::run_documentation()) { #And here it is evaluated with additional interactions included: eval_design_mc(design = designcoffee, model = ~cost + type + size + cost * type, 0.05,               nsim = 100, glmfamily = \"gaussian\") } #>      parameter               type power #> 1  (Intercept)    effect.power.mc  0.98 #> 2         cost    effect.power.mc  0.98 #> 3         type    effect.power.mc  0.93 #> 4         size    effect.power.mc  0.88 #> 5    cost:type    effect.power.mc  0.83 #> 6  (Intercept) parameter.power.mc  0.98 #> 7         cost parameter.power.mc  0.98 #> 8        type1 parameter.power.mc  0.70 #> 9        type2 parameter.power.mc  0.67 #> 10       type3 parameter.power.mc  0.64 #> 11       size1 parameter.power.mc  0.82 #> 12       size2 parameter.power.mc  0.84 #> 13  cost:type1 parameter.power.mc  0.63 #> 14  cost:type2 parameter.power.mc  0.63 #> 15  cost:type3 parameter.power.mc  0.58 #> ============Evaluation Info============ #> • Alpha = 0.05 • Trials = 21 • Blocked = FALSE  #> • Evaluating Model = ~cost + type + size + cost:type  #> • Anticipated Coefficients = c(1, 1, 1, -1, 1, 1, -1, 1, -1, 1)  #> • Contrasts = `contr.sum`  #> • Parameter Analysis Method = `lm(...)`  #> • Effect Analysis Method = `car::Anova(fit, type = \"III\")`  if(skpr:::run_documentation()) { #We can also set \"parallel = TRUE\" to use all the cores available to speed up #computation. eval_design_mc(design = designcoffee, nsim = 10000,                        glmfamily = \"gaussian\", parallel = TRUE) } #> Error in globalCallingHandlers(condition = global_progression_handler): should not be called with handlers on the stack if(skpr:::run_documentation()) { #We can also evaluate split-plot designs. First, let us generate the split-plot design:  factorialcoffee2 = expand.grid(Temp = c(1, -1),                                Store = as.factor(c(\"A\", \"B\")),                                cost = c(-1, 1),                                type = as.factor(c(\"Kona\", \"Colombian\", \"Ethiopian\", \"Sumatra\")),                                size = as.factor(c(\"Short\", \"Grande\", \"Venti\")))  vhtcdesign = gen_design(factorialcoffee2,                        model = ~Store, trials = 6, varianceratio = 1) htcdesign = gen_design(factorialcoffee2, model = ~Store + Temp, trials = 18,                        splitplotdesign = vhtcdesign, blocksizes = rep(3, 6), varianceratio = 1) splitplotdesign = gen_design(factorialcoffee2,                             model = ~Store + Temp + cost + type + size, trials = 54,                             splitplotdesign = htcdesign, blocksizes = rep(3, 18),                             varianceratio = 1)  #Each block has an additional noise term associated with it in addition to the normal error #term in the model. This is specified by a vector specifying the additional variance for #each split-plot level. This is equivalent to specifying a variance ratio of one between #the whole plots and the run-to-run variance for gaussian models.  #Evaluate the design. Note the decreased power for the blocking factors. eval_design_mc(splitplotdesign, blocking = TRUE, nsim = 100,                        glmfamily = \"gaussian\", varianceratios = c(1, 1, 1)) } #>      parameter               type power #> 1        Store    effect.power.mc  0.38 #> 2         Temp    effect.power.mc  0.82 #> 3         cost    effect.power.mc  1.00 #> 4         type    effect.power.mc  1.00 #> 5         size    effect.power.mc  1.00 #> 6  (Intercept) parameter.power.mc  0.34 #> 7       Store1 parameter.power.mc  0.38 #> 8         Temp parameter.power.mc  0.82 #> 9         cost parameter.power.mc  1.00 #> 10       type1 parameter.power.mc  0.99 #> 11       type2 parameter.power.mc  0.96 #> 12       type3 parameter.power.mc  0.98 #> 13       size1 parameter.power.mc  1.00 #> 14       size2 parameter.power.mc  1.00 #> ============Evaluation Info============ #> • Alpha = 0.05 • Trials = 54 • Blocked = TRUE  #> • Evaluating Model = ~Store + Temp + cost + type + size  #> • Anticipated Coefficients = c(1, 1, 1, 1, 1, -1, 1, 1, -1)  #> • Number of Blocks = Level 1: 6, Level 2: 18  #> • Variance Ratios  = Level 1: 1, Level 2: 1, Level 3: 1  #> • Contrasts = `contr.sum`  #> • Parameter Analysis Method = `lmerTest::lmer(...)`  #> • Effect Analysis Method = `car::Anova(fit, type = \"III\")`  if(skpr:::run_documentation()) { #We can also use this method to evaluate designs that cannot be easily #evaluated using normal approximations. Here, we evaluate a design with a binomial response and see #whether we can detect the difference between each factor changing whether an event occurs #70% of the time or 90% of the time.  factorialbinom = expand.grid(a = c(-1, 1), b = c(-1, 1)) designbinom = gen_design(factorialbinom, model = ~a + b, trials = 90, optimality = \"D\")  eval_design_mc(designbinom, ~a + b, alpha = 0.2, nsim = 100, effectsize = c(0.7, 0.9),               glmfamily = \"binomial\") } #>     parameter               type power #> 1 (Intercept)    effect.power.mc  1.00 #> 2           a    effect.power.mc  0.90 #> 3           b    effect.power.mc  0.89 #> 4 (Intercept) parameter.power.mc  1.00 #> 5           a parameter.power.mc  0.90 #> 6           b parameter.power.mc  0.89 #> ===========Evaluation Info============ #> • Alpha = 0.2 • Trials = 90 • Blocked = FALSE  #> • Evaluating Model = ~a + b  #> • Anticipated Coefficients = c(1.522, 0.675, 0.675)  #> • Contrasts = `contr.sum`  #> • Parameter Analysis Method = glm(..., family = \"binomial\")`  #> • Effect Analysis Method = `car::Anova(fit, type = \"III\")`  if(skpr:::run_documentation()) { #We can also use this method to determine power for poisson response variables. #Generate the design:  factorialpois = expand.grid(a = as.numeric(c(-1, 0, 1)), b = c(-1, 0, 1)) designpois = gen_design(factorialpois, ~a + b, trials = 70, optimality = \"D\")  #Evaluate the power:  eval_design_mc(designpois, ~a + b, 0.05, nsim = 100, glmfamily = \"poisson\",                anticoef = log(c(0.2, 2, 2))) } #>     parameter               type power #> 1 (Intercept)    effect.power.mc  0.95 #> 2           a    effect.power.mc  0.80 #> 3           b    effect.power.mc  0.82 #> 4 (Intercept) parameter.power.mc  0.95 #> 5           a parameter.power.mc  0.80 #> 6           b parameter.power.mc  0.82 #> ===========Evaluation Info============ #> • Alpha = 0.05 • Trials = 70 • Blocked = FALSE  #> • Evaluating Model = ~a + b  #> • Anticipated Coefficients = c(-1.609, 0.693, 0.693)  #> • Contrasts = `contr.sum`  #> • Parameter Analysis Method = `glm(..., family = \"poisson\")`  #> • Effect Analysis Method = `car::Anova(fit, type = \"III\")`   #The coefficients above set the nominal value -- that is, the expected count #when all inputs = 0 -- to 0.2 (from the intercept), and say that each factor #changes this count by a factor of 4 (multiplied by 2 when x= +1, and divided by 2 when x = -1). #Note the use of log() in the anticipated coefficients."},{"path":"https://tylermorganwall.github.io/skpr/reference/eval_design_survival_mc.html","id":null,"dir":"Reference","previous_headings":"","what":"Evaluate Power for Survival Design — eval_design_survival_mc","title":"Evaluate Power for Survival Design — eval_design_survival_mc","text":"Evaluates power experimental design response variable may right- left-censored. Power evaluated Monte Carlo simulation, using survival package survreg fit data. Split-plot designs supported.","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/eval_design_survival_mc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Evaluate Power for Survival Design — eval_design_survival_mc","text":"","code":"eval_design_survival_mc(   design,   model = NULL,   alpha = 0.05,   nsim = 1000,   distribution = \"gaussian\",   censorpoint = NA,   censortype = \"right\",   rfunctionsurv = NULL,   anticoef = NULL,   effectsize = 2,   contrasts = contr.sum,   parallel = FALSE,   detailedoutput = FALSE,   progress = TRUE,   advancedoptions = NULL,   ... )"},{"path":"https://tylermorganwall.github.io/skpr/reference/eval_design_survival_mc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Evaluate Power for Survival Design — eval_design_survival_mc","text":"design experimental design. Internally, numeric columns rescaled [-1, +1]. model model used evaluating design. missing design generated skpr, generating model used. can subset model used generate design, include higher order effects original design generation. include factors present experimental design. alpha Default `0.05`. type-error. p-values less counted significant. nsim number simulations. Default 1000. distribution Distribution survival function use fitting data. Valid choices described documentation survreg. Supported options \"exponential\", \"lognormal\", \"gaussian\". Default \"gaussian\". censorpoint point /(right-censored left-censored data, respectively) data labelled censored. Default NA censoring. argument used internal random number generators; supply function rfunctionsurv parameter, parameter ignored. censortype type censoring (either \"left\" \"right\"). Default \"right\". rfunctionsurv Random number generator function. function form f(X, b), X model matrix b anticipated coefficients. function return Surv object survival package. need provide argument distribution one supported choices satisfied default behavior described . anticoef anticipated coefficients calculating power. missing, coefficients automatically generated based effectsize argument. effectsize Helper argument generate anticipated coefficients. See details info. specify anticoef, effectsize ignored. contrasts Default contr.sum. Function used encode categorical variables model matrix. user specified contrasts categorical factor using contrasts function, used. Otherwise, skpr use contr.sum. parallel Default `FALSE`. `TRUE`, power simulation use one available cores. user wants set number cores manually, can setting `options(\"cores\")` desired number (e.g. `options(\"cores\" = parallel::detectCores())`). NOTE: installed BLAS libraries include multicore support (e.g. Intel MKL comes Microsoft R Open), turning parallel result reduced performance. detailedoutput Default `FALSE`. `TRUE`, return additional information evaluation results. progress Default `TRUE`. Whether include progress bar. advancedoptions Default `NULL`. Named list advanced options. Pass `progressBarUpdater` include function called non-parallel simulations can used update external progress bar. `advancedoptions$ci_error_conf` set confidence level power intervals, printed `detailedoutput = TRUE`. ... additional arguments passed survreg function fitting.","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/eval_design_survival_mc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Evaluate Power for Survival Design — eval_design_survival_mc","text":"data frame consisting parameters powers. parameter estimates simulations stored 'estimates' attribute. 'modelmatrix' attribute contains model matrix encoding used categorical factors. manually specify anticipated coefficients, order model matrix.","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/eval_design_survival_mc.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Evaluate Power for Survival Design — eval_design_survival_mc","text":"Evaluates power design Monte Carlo simulation. Data simulated fit survival model (survival::survreg), fraction simulations parameter significant (p-value less specified alpha) estimate power parameter. supplied user, rfunctionsurv generated based distribution argument follows: case, simulated data point past censorpoint (greater right-censored, less left-censored) marked censored. See examples construct function. Power dependent anticipated coefficients. can specify directly anticoef argument, can use effectsize argument specify effect size skpr auto-generate . can provide either length-1 length-2 vector. provide length-1 vector, anticipated coefficients half effectsize; equivalent saying linear predictor (gaussian model, mean response; exponential model lognormal model, log mean value) changes effectsize continuous factor goes lowest level highest level. provide length-2 vector, anticipated coefficients set mean response changes effectsize[1] effectsize[2] factor goes lowest level highest level, assuming factors inactive (x-values zero). effect length-2 effectsize depends distribution argument follows: distribution = 'gaussian', coefficients set (effectsize[2] - effectsize[1]) / 2. distribution = 'exponential' 'lognormal', intercept 1 / 2 * (log(effectsize[2]) + log(effectsize[1])), coefficients 1 / 2 * (log(effectsize[2]) - log(effectsize[1])).","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/eval_design_survival_mc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Evaluate Power for Survival Design — eval_design_survival_mc","text":"","code":"#These examples focus on the survival analysis case and assume familiarity #with the basic functionality of eval_design_mc.  #We first generate a simple 2-level design using expand.grid: basicdesign = expand.grid(a = c(-1, 1)) design = gen_design(candidateset = basicdesign, model = ~a, trials = 15)  #We can then evaluate the power of the design in the same way as eval_design_mc, #now including the type of censoring (either right or left) and the point at which #the data should be censored:  eval_design_survival_mc(design = design, model = ~a, alpha = 0.05,                         nsim = 100, distribution = \"exponential\",                         censorpoint = 5, censortype = \"right\") #> Warning: default or length 1 delta used with distribution == 'exponential'. This can lead to unrealistic effect sizes - make sure the generated anticipated coeffcients are appropriate. #>     parameter               type power #> 1 (Intercept) parameter.power.mc  0.91 #> 2           a parameter.power.mc  0.89 #> ===========Evaluation Info============ #> • Alpha = 0.05 • Trials = 15 • Blocked = FALSE  #> • Evaluating Model =   #> • Anticipated Coefficients = c(1, 1)   #Built-in Monte Carlo random generating functions are included for the gaussian, exponential, #and lognormal distributions.  #We can also evaluate different censored distributions by specifying a custom #random generating function and changing the distribution argument.  rlognorm = function(X, b) {   Y = rlnorm(n = nrow(X), meanlog = X %*% b, sdlog = 0.4)   censored = Y > 1.2   Y[censored] = 1.2   return(survival::Surv(time = Y, event = !censored, type = \"right\")) }  #Any additional arguments are passed into the survreg function call.  As an example, you #might want to fix the \"scale\" argument to survreg, when fitting a lognormal:  eval_design_survival_mc(design = design, model = ~a, alpha = 0.2, nsim = 100,                         distribution = \"lognormal\", rfunctionsurv = rlognorm,                         anticoef = c(0.184, 0.101), scale = 0.4) #>     parameter               type power #> 1 (Intercept) parameter.power.mc  0.51 #> 2           a parameter.power.mc  0.40 #> ===========Evaluation Info============ #> • Alpha = 0.2 • Trials = 15 • Blocked = FALSE  #> • Evaluating Model =   #> • Anticipated Coefficients = c(0.184, 0.101)"},{"path":"https://tylermorganwall.github.io/skpr/reference/extractPvalues.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract p-values from a model object — extractPvalues","title":"Extract p-values from a model object — extractPvalues","text":"Extract p-values model object. Currently works lm, glm, lme4, glmer, survreg model objects. possible, uses p-values reported summary(model_fit).","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/extractPvalues.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract p-values from a model object — extractPvalues","text":"","code":"extractPvalues(model_fit, glmfamily = \"gaussian\")"},{"path":"https://tylermorganwall.github.io/skpr/reference/extractPvalues.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract p-values from a model object — extractPvalues","text":"model_fit model object extract.","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/extractPvalues.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract p-values from a model object — extractPvalues","text":"Returns vector p-values. model_fit supported model type, returns NULL.","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/gen_anticoef.html","id":null,"dir":"Reference","previous_headings":"","what":"Generates Anticipated Coefficients — gen_anticoef","title":"Generates Anticipated Coefficients — gen_anticoef","text":"Generates Anticipated Coefficients","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/gen_anticoef.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generates Anticipated Coefficients — gen_anticoef","text":"","code":"gen_anticoef(RunMatrix, model, nointercept)"},{"path":"https://tylermorganwall.github.io/skpr/reference/gen_anticoef.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generates Anticipated Coefficients — gen_anticoef","text":"RunMatrix run matrix model model nointercept TRUE intercept model","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/gen_anticoef.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generates Anticipated Coefficients — gen_anticoef","text":"Anticipated coefficients.","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/gen_binomial_anticoef.html","id":null,"dir":"Reference","previous_headings":"","what":"Generates Binomial Anticipated Coefficients — gen_binomial_anticoef","title":"Generates Binomial Anticipated Coefficients — gen_binomial_anticoef","text":"Generates Binomial Anticipated Coefficients Solves logistic function log(p / (1-p)) = beta0 + beta1 * x p = lowprob x = -1, p = highprob x = +1. Equivalently, solves set equations beta0 beta1: log(lowprob / (1 - lowprob)) = beta0 - beta1 log(highprob / (1 - highprob)) = beta0 + beta1","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/gen_binomial_anticoef.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generates Binomial Anticipated Coefficients — gen_binomial_anticoef","text":"","code":"gen_binomial_anticoef(anticoef, lowprob, highprob)"},{"path":"https://tylermorganwall.github.io/skpr/reference/gen_binomial_anticoef.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generates Binomial Anticipated Coefficients — gen_binomial_anticoef","text":"anticoef Anticipated coefficients lowprob Default 0.50. base probability highprob Default 0.80. high probability","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/gen_binomial_anticoef.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generates Binomial Anticipated Coefficients — gen_binomial_anticoef","text":"Anticipated coefficients.","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/gen_design.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate optimal experimental designs — gen_design","title":"Generate optimal experimental designs — gen_design","text":"Creates experimental design given model, desired number runs, data frame candidate test points. gen_design chooses points candidate set returns design optimal given statistical model.","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/gen_design.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate optimal experimental designs — gen_design","text":"","code":"gen_design(   candidateset,   model,   trials,   splitplotdesign = NULL,   blocksizes = NULL,   optimality = \"D\",   augmentdesign = NULL,   repeats = 20,   custom_v = NULL,   varianceratio = 1,   contrast = contr.simplex,   aliaspower = 2,   minDopt = 0.8,   k = NA,   parallel = FALSE,   progress = TRUE,   add_blocking_columns = FALSE,   randomized = TRUE,   advancedoptions = NULL,   timer = NULL )"},{"path":"https://tylermorganwall.github.io/skpr/reference/gen_design.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate optimal experimental designs — gen_design","text":"candidateset data frame candidate test points; run optimal design chosen (replacement) candidate set. row data frame candidate test point. row unique. Usually full factorial test matrix generated factors model unless disallowed combinations runs. Factors present candidate set present model stripped , duplicate entries candidate set removed. Disallowed combinations can specified simply removing candidate set. Disallowed combinations hard--change easy--change factor detected comparing internal candidate set generated unique levels present candidate set split plot design. points excluded search. factor continuous, column type numeric. factor categorical, column type factor character. model statistical model used generate test design. trials number runs design. splitplotdesign `NULL`, fully randomized design generated. NULL, split-plot design generated, argument specifies design factors harder change current set factors. row corresponds block harder change factors held constant. row splitplotdesign replicated specified blocksizes, optimal design found factors given model argument, taking consideration fixed replicated hard--change factors. blocksizes missing, `gen_design` attempt allocate runs balanced design possible, given number blocks given argument `splitplotdesign` total number `trials`. blocksizes Default `NULL`. Specifies block size(s) design generation. one number passed, `gen_design()` create blocks specified size, total number run specified `trials` divisible number, `gen_design()` attempt allocate runs balanced design possible. list passed, entry list specify additional layer blocking. `splitplotdesign` `NULL`, argument specifies number subplots within whole plot (whole plot corresponding row `splitplotdesign` data.frame). optimality Default `D`. optimality criterion used generating design. Full list supported criteria: \"D\", \"\", \"\", \"ALIAS\", \"G\", \"T\", \"E\", \"CUSTOM\". \"CUSTOM\", user must also define function model matrix named `customOpt` namespace returns single value, algorithm attempt optimize. `CUSTOM` optimality split-plot designs, user must instead define `customBlockedOpt`, function model matrix variance-covariance matrix. information algorithm behind Alias-optimal designs, see Jones Nachtsheim. \"Efficient Designs Minimal Aliasing.\" Technometrics, vol. 53, . 1, 2011, pp. 62-71. augmentdesign Default NULL. `data.frame` runs fixed optimal search process. columns `augmentdesign` must match candidate set. search algorithm search optimal `trials` - `nrow(augmentdesign)` remaining runs. repeats Default `20`. number times repeat search best optimal design. custom_v Default `NULL`. user can pass custom variance-covariance matrix used blocked design generation. varianceratio Default `1`. ratio block run--run variance given stratum split plot/blocked design. requires design passed `splitplotdesign`, overridden `1` split plot design entered. contrast Default `contr.simplex`, orthonormal sum contrast. Function used generate encoding categorical variables. aliaspower Default `2`. Degree interactions used calculating alias matrix alias optimal designs. minDopt Default `0.8`. Minimum value D-Optimality design searching Alias-optimal designs. k Default `NA`. D-optimal designs, changes search k-exchange algorithm Johnson Nachtsheim. \"Guidelines Constructing Exact D-Optimal Designs Convex Design Spaces.\" Technometrics, vol. 25, 1983, pp. 271-277. exchanges k lowest variance runs design search iteration. Lower numbers can result faster search, less likely tofind optimal design. Values `k >= n/4` shown empirically generate similar designs full search. `k == trials`, results default modified Federov's algorithm. `k` 1 form Wynn's algorithm Wynn. \"Results Theory Construction D-Optimum Experimental Designs,\" Journal Royal Statistical Society, Ser. B,vol. 34, 1972, pp. 133-14. parallel Default `FALSE`. `TRUE`, optimal design search use one available cores. can lead substantial speed-search complex designs. user wants set number cores manually, can setting `options(\"cores\")` desired number (e.g. `options(\"cores\" = parallel::detectCores())`). NOTE: installed BLAS libraries include multicore support (e.g. Intel MKL comes Microsoft R Open), turning parallel result reduced performance. progress Default `TRUE`. Whether include progress bar. add_blocking_columns Default `FALSE`. blocking structure design indicated row names returned design. `TRUE`, design also extra columns indicate blocking structure. blocking detected, columns added. randomized Default `TRUE`, due intrinsic randomization design search algorithm. `FALSE`, randomized design re-ordered left right. advancedoptions Default `NULL`. named list advanced users want adjust optimal design algorithm parameters. Advanced option names `design_search_tolerance` (smallest fractional increase design search terminates), `alias_tie_power` (degree aliasing matrix calculating optimality tie-breakers), `alias_tie_tolerance` (smallest absolute difference optimality criterion designs considered equal considering aliasing structure),  `alias_compare“ (set FALSE turns alias tie breaking completely), `aliasmodel` (provided user want calculate Alias-optimality using `aliaspower` interaction terms), `progressBarUpdater“ (function called non-parallel optimal searches can used update external progress bar). Finally, `g_efficiency_method`, sets method used calculate G-efficiency (default \"random\" random Monte Carlo sampling design space, \"optim\" use simulated annealing, \"custom\" explicitly define points design space, fastest method way calculate prediction variance disallowed combinations). , also `g_efficiency_samples`, specifies number random samples  (default 1000 `g_efficiency_method = \"random\"`), attempts simulated annealing (default 1 `g_efficiency_method = \"optim\"`), data.frame defining exact points design space `g_efficiency_method = \"custom\"`. timer Deprecated: Use `progress` instead.","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/gen_design.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate optimal experimental designs — gen_design","text":"data frame containing run matrix optimal design. returned data frame contains supplementary information attributes, can accessed `get_attributes()` `get_optimality()` functions.","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/gen_design.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate optimal experimental designs — gen_design","text":"Split-plot designs can generated repeated applications gen_design; see examples details.","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/gen_design.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate optimal experimental designs — gen_design","text":"","code":"#Generate the basic factorial candidate set with expand.grid. #Generating a basic 2 factor candidate set: basic_candidates = expand.grid(x1 = c(-1, 1), x2 = c(-1, 1))  #This candidate set is used as an input in the optimal design generation for a #D-optimal design with 11 runs. design = gen_design(candidateset = basic_candidates, model = ~x1 + x2, trials = 11)  #We can also use the dot formula to automatically use all of the terms in the model: design = gen_design(candidateset = basic_candidates, model = ~., trials = 11)  #Here we add categorical factors, specified by using \"as.factor\" in expand.grid: categorical_candidates = expand.grid(a = c(-1, 1),                                      b = as.factor(c(\"A\", \"B\")),                                      c = as.factor(c(\"High\", \"Med\", \"Low\")))  #This candidate set is used as an input in the optimal design generation. design2 = gen_design(candidateset = categorical_candidates, model = ~a + b + c, trials = 19)  #We can also increase the number of times the algorithm repeats #the search to increase the probability that the globally optimal design was found. design2 = gen_design(candidateset = categorical_candidates,                     model = ~a + b + c, trials = 19, repeats = 100)  #We can perform a k-exchange algorithm instead of a full search to help speed up #the search process, although this can lead to less optimal designs. Here, we only #exchange the 10 lowest variance runs in each search iteration. if(skpr:::run_documentation()) { design_k = gen_design(candidateset = categorical_candidates,                     model = ~a + b + c, trials = 19, repeats = 100, k = 10) }  #To speed up the design search, you can turn on multicore support with the parallel option. #You can also customize the number of cores used by setting the cores option. By default, #all cores are used. if(skpr:::run_documentation()) { options(cores = 2) design2 = gen_design(categorical_candidates,                     model = ~a + b + c, trials = 19, repeats = 1000, parallel = TRUE) } #> Loading required package: foreach #> Loading required package: future  #You can also use a higher order model when generating the design: design2 = gen_design(categorical_candidates,                     model = ~a + b + c + a * b * c, trials = 12, repeats = 10)  #To evaluate a response surface design, include center points #in the candidate set and include quadratic effects (but not for the categorical factors).  quad_candidates = expand.grid(a = c(1, 0, -1), b = c(-1, 0, 1), c = c(\"A\", \"B\", \"C\"))  gen_design(quad_candidates, ~a + b + I(a^2) + I(b^2) + a * b * c, 20) #>     a  b c #> 1   1  1 A #> 2  -1 -1 B #> 3  -1 -1 C #> 4  -1  1 A #> 5  -1  1 B #> 6  -1 -1 A #> 7   1  1 B #> 8   0  1 B #> 9   1 -1 B #> 10  1  1 C #> 11  1  1 A #> 12 -1  1 C #> 13  0  0 C #> 14 -1  1 A #> 15  1 -1 C #> 16  0 -1 B #> 17  1 -1 A #> 18 -1  0 B #> 19  1 -1 A #> 20  1  0 B  #The optimality criterion can also be changed: gen_design(quad_candidates, ~a + b + I(a^2) + I(b^2) + a * b * c, 20,           optimality = \"I\", repeats = 10) #>     a  b c #> 1  -1  1 C #> 2   0  0 C #> 3   1 -1 C #> 4   1 -1 A #> 5  -1  1 A #> 6  -1 -1 C #> 7   1  1 C #> 8  -1  1 B #> 9  -1  0 B #> 10  1 -1 B #> 11  1  0 B #> 12  1  1 B #> 13  0  0 A #> 14  1  1 A #> 15 -1 -1 A #> 16  0  0 A #> 17  0  0 C #> 18  0  1 B #> 19  0 -1 B #> 20 -1 -1 B gen_design(quad_candidates, ~a + b + I(a^2) + I(b^2) + a * b * c, 20,           optimality = \"A\", repeats = 10) #>     a  b c #> 1  -1 -1 B #> 2   1  1 C #> 3   1 -1 B #> 4   1 -1 A #> 5   1  0 C #> 6   1 -1 C #> 7  -1  0 C #> 8  -1 -1 A #> 9  -1 -1 C #> 10 -1  1 A #> 11  0  0 B #> 12  0  0 B #> 13  1  1 A #> 14  0  1 C #> 15  0  0 A #> 16  1  1 B #> 17  1  0 A #> 18  0 -1 C #> 19 -1  1 B #> 20 -1  1 C  #A blocked design can be generated by specifying the `blocksizes` argument. Passing a single #number will create designs with blocks of that size, while passing multiple values in a list #will specify multiple layers of blocking.  #Specify a single layer gen_design(quad_candidates, ~a + b + c, 21, blocksizes=3, add_blocking_column=TRUE) #>    Block1  a  b c #> 1       1  1 -1 C #> 2       1  1  1 B #> 3       1 -1  1 A #> 4       2  1  1 B #> 5       2  1  1 A #> 6       2 -1 -1 C #> 7       3 -1  1 C #> 8       3  1 -1 B #> 9       3  1 -1 A #> 10      4 -1  1 A #> 11      4  1 -1 C #> 12      4 -1 -1 B #> 13      5  1  1 C #> 14      5 -1  1 B #> 15      5  1 -1 A #> 16      6  1  1 B #> 17      6 -1  1 C #> 18      6 -1 -1 A #> 19      7 -1 -1 B #> 20      7  1  1 C #> 21      7  1  1 A  #Manually specify the block sizes for a single layer, must add to `trials`` gen_design(quad_candidates, ~a + b + c, 21, blocksizes=c(4,3,2,3,3,3,3),           add_blocking_column=TRUE) #>    Block1  a  b c #> 1       1 -1 -1 B #> 2       1  1  1 B #> 3       1  1  1 A #> 4       1 -1 -1 C #> 5       2  1 -1 A #> 6       2 -1  1 B #> 7       2 -1  1 C #> 8       3  1  1 C #> 9       3 -1 -1 A #> 10      4 -1  1 B #> 11      4 -1  1 A #> 12      4  1 -1 C #> 13      5 -1  1 C #> 14      5  1 -1 B #> 15      5 -1  1 A #> 16      6  1  1 A #> 17      6 -1  1 C #> 18      6 -1 -1 B #> 19      7  1  1 B #> 20      7  1 -1 C #> 21      7 -1 -1 A  #Multiple layers of blocking gen_design(quad_candidates, ~a + b + c, 21, blocksizes=list(7,3),           add_blocking_column=TRUE) #>    Block1 b  c NA NA #> 1       1 1 -1 -1  A #> 2       1 1  1 -1  C #> 3       1 1  1  1  B #> 4       1 2  1  1  B #> 5       1 2 -1  1  C #> 6       1 2 -1 -1  A #> 7       1 3  1  1  A #> 8       2 3  1 -1  C #> 9       2 3 -1  1  B #> 10      2 4  1 -1  B #> 11      2 4 -1  1  C #> 12      2 4  1  1  A #> 13      2 5 -1  1  A #> 14      2 5  1 -1  B #> 15      3 5 -1 -1  C #> 16      3 6  1  1  A #> 17      3 6 -1 -1  B #> 18      3 6  1  1  C #> 19      3 7 -1  1  B #> 20      3 7  1 -1  A #> 21      3 7  1  1  C  #Multiple layers of blocking, specified individually gen_design(quad_candidates, ~a + b + c, 21, blocksizes=list(7,c(4,3,2,3,3,3,3)),           add_blocking_column=TRUE) #>    Block1 b  c NA NA #> 1       1 1  1  1  A #> 2       1 1  1  1  B #> 3       1 1 -1 -1  B #> 4       1 1 -1 -1  C #> 5       1 2 -1  1  C #> 6       1 2 -1  1  A #> 7       1 2  1 -1  B #> 8       2 3  1  1  A #> 9       2 3 -1 -1  B #> 10      2 4  1  1  C #> 11      2 4 -1  1  B #> 12      2 4 -1 -1  A #> 13      2 5  1 -1  C #> 14      2 5 -1  1  B #> 15      3 5 -1  1  A #> 16      3 6  1  1  B #> 17      3 6 -1 -1  A #> 18      3 6  1 -1  C #> 19      3 7  1 -1  A #> 20      3 7  1 -1  B #> 21      3 7 -1  1  C  #A split-plot design can be generated by first generating an optimal blocking design using the #hard-to-change factors and then using that as the input for the split-plot design. #This generates an optimal subplot design that accounts for the existing split-plot settings.  splitplotcandidateset = expand.grid(Altitude = c(-1, 1),                                     Range = as.factor(c(\"Close\", \"Medium\", \"Far\")),                                     Power = c(1, -1)) hardtochangedesign = gen_design(splitplotcandidateset, model = ~Altitude,                                trials = 11, repeats = 10)  #Now we can use the D-optimal blocked design as an input to our full design.  #Here, we add the easy to change factors from the candidate set to the model, #and input the hard-to-change design along with the new number of trials. `gen_design` will #automatically allocate the runs in the blocks in the most balanced way possible.  designsplitplot = gen_design(splitplotcandidateset, ~Altitude + Range + Power, trials = 33,                              splitplotdesign = hardtochangedesign, repeats = 10)  #If we want to allocate the blocks manually, we can do that with the argument `blocksizes`. This #vector must sum to the number of `trials` specified.  #Putting this all together: designsplitplot = gen_design(splitplotcandidateset, ~Altitude + Range + Power, trials = 33,                              splitplotdesign = hardtochangedesign,                              blocksizes = c(4, 2, 3, 4, 2, 3, 4, 2, 3, 4, 2), repeats = 10)  #The split-plot structure is encoded into the row names, with a period #demarcating the blocking level. This process can be repeated for arbitrary #levels of blocking (i.e. a split-plot design can be entered in as the hard-to-change #to produce a split-split-plot design, which can be passed as another #hard-to-change design to produce a split-split-split plot design, etc). #In the following, note that the model builds up as we build up split plot strata.  splitplotcandidateset2 = expand.grid(Location = as.factor(c(\"East\", \"West\")),                                      Climate = as.factor(c(\"Dry\", \"Wet\", \"Arid\")),                                      Vineyard = as.factor(c(\"A\", \"B\", \"C\", \"D\")),                                      Age = c(1, -1)) #6 blocks of Location: temp = gen_design(splitplotcandidateset2, ~Location, trials = 6, varianceratio = 2, repeats = 10) #> Warning: varianceratio cannot be set when split-plot design is not null.  #Each Location block has 2 blocks of Climate: temp = gen_design(splitplotcandidateset2, ~Location + Climate,                   trials = 12, splitplotdesign = temp, blocksizes = 2,                   varianceratio = 1, repeats = 10)  #Each Climate block has 4 blocks of Vineyard: temp = gen_design(splitplotcandidateset2, ~Location + Climate + Vineyard,                   trials = 48, splitplotdesign = temp, blocksizes = 4,                   varianceratio = 1, repeats = 10)  #Each Vineyard block has 4 runs with different Age: if(skpr:::run_documentation()) { splitsplitsplitplotdesign = gen_design(splitplotcandidateset2, ~Location + Climate + Vineyard + Age,                                        trials = 192, splitplotdesign = temp, blocksizes = 4,                                        varianceratio = 1, add_blocking_columns = TRUE) } #gen_design also supports user-defined optimality criterion. The user defines a function #of the model matrix named customOpt, and gen_design will attempt to generate a design #that maximizes that function. This function needs to be in the global environment, and be #named either customOpt or customBlockedOpt, depending on whether a split-plot design is being #generated. customBlockedOpt should be a function of the model matrix as well as the #variance-covariance matrix, vInv. Due to the underlying C + + code having to call back to the R #environment repeatedly, this criterion will be significantly slower than the built-in algorithms. #It does, however, offer the user a great deal of flexibility in generating their designs.  #We are going to write our own D-optimal search algorithm using base R functions. Here, write #a function that calculates the determinant of the information matrix. gen_design will search #for a design that maximizes this function.  customOpt = function(currentDesign) {  return(det(t(currentDesign) %*% currentDesign)) }  #Generate the whole plots for our split-plot design, using the custom criterion.  candlistcustom = expand.grid(Altitude = c(10000, 20000),                             Range = as.factor(c(\"Close\", \"Medium\", \"Far\")),                             Power = c(50, 100)) htcdesign = gen_design(candlistcustom, model = ~Altitude + Range,                       trials = 11, optimality = \"CUSTOM\", repeats = 10) #> Error: Cannot convert object to a function: [type=NULL; target=CLOSXP, SPECIALSXP, or BUILTINSXP].  #Now define a function that is a function of both the model matrix, #as well as the variance-covariance matrix vInv. This takes the blocking structure into account #when calculating our determinant.  customBlockedOpt = function(currentDesign, vInv) {  return(det(t(currentDesign) %*% vInv %*% currentDesign)) }  #And finally, calculate the design. This (likely) results in the same design had we chosen the #\"D\" criterion.  design = gen_design(candlistcustom,                    ~Altitude + Range + Power, trials = 33,                    splitplotdesign = htcdesign, blocksizes = 3,                    optimality = \"CUSTOM\", repeats = 10) #> Error: object 'htcdesign' not found  #gen_design can also augment an existing design. Input a dataframe of pre-existing runs #to the `augmentdesign` argument. Those runs in the new design will be fixed, and gen_design #will perform a search for the remaining `trials - nrow(augmentdesign)` runs.  candidateset = expand.grid(height = c(10, 20), weight = c(45, 55, 65), range = c(1, 2, 3))  design_to_augment = gen_design(candidateset, ~height + weight + range, 5)  #As long as the columns in the augmented design match the columns in the candidate set, #this design can be augmented.  augmented_design = gen_design(candidateset,                              ~height + weight + range, 16, augmentdesign = design_to_augment)  #A design's diagnostics can be accessed via the `get_optimality()` function:  get_optimality(augmented_design) #>     D     I   A            G  T  E    Alias #> 1 100 0.125 100 Not Computed 64 16 58318.89  #And design attributes can be accessed with the `get_attribute()` function:  get_attribute(design) #> $model.matrix #>       (Intercept) x1 x2 #>  [1,]           1 -1  1 #>  [2,]           1  1 -1 #>  [3,]           1  1 -1 #>  [4,]           1  1 -1 #>  [5,]           1  1  1 #>  [6,]           1 -1 -1 #>  [7,]           1 -1  1 #>  [8,]           1 -1 -1 #>  [9,]           1 -1 -1 #> [10,]           1  1  1 #> [11,]           1  1  1 #>  #> $moments.matrix #>             (Intercept)        x1        x2 #> (Intercept)           1 0.0000000 0.0000000 #> x1                    0 0.3333333 0.0000000 #> x2                    0 0.0000000 0.3333333 #>  #> $variance.matrix #>       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] #>  [1,]    1    0    0    0    0    0    0    0    0     0     0 #>  [2,]    0    1    0    0    0    0    0    0    0     0     0 #>  [3,]    0    0    1    0    0    0    0    0    0     0     0 #>  [4,]    0    0    0    1    0    0    0    0    0     0     0 #>  [5,]    0    0    0    0    1    0    0    0    0     0     0 #>  [6,]    0    0    0    0    0    1    0    0    0     0     0 #>  [7,]    0    0    0    0    0    0    1    0    0     0     0 #>  [8,]    0    0    0    0    0    0    0    1    0     0     0 #>  [9,]    0    0    0    0    0    0    0    0    1     0     0 #> [10,]    0    0    0    0    0    0    0    0    0     1     0 #> [11,]    0    0    0    0    0    0    0    0    0     0     1 #>  #> $alias.matrix #>             x1 x2      x1:x2 #> (Intercept)  0  0  0.1111111 #> x1           1  0 -0.1111111 #> x2           0  1  0.1111111 #>  #> $correlation.matrix #>            x1         x2 #> x1 1.00000000 0.09090909 #> x2 0.09090909 1.00000000 #>  #> $model #> ~x1 + x2 #> <environment: 0x55eee420b990> #>   #A correlation color map can be produced by calling the plot_correlation command with the output #of gen_design()  if(skpr:::run_documentation()) { plot_correlations(design2) }   #A fraction of design space plot can be produced by calling the plot_fds command if(skpr:::run_documentation()) { plot_fds(design2) }   #Evaluating the design for power can be done with eval_design, eval_design_mc (Monte Carlo) #eval_design_survival_mc (Monte Carlo survival analysis), and #eval_design_custom_mc (Custom Library Monte Carlo)"},{"path":"https://tylermorganwall.github.io/skpr/reference/gen_exponential_anticoef.html","id":null,"dir":"Reference","previous_headings":"","what":"Generates Exponential Anticipated Coefficients — gen_exponential_anticoef","title":"Generates Exponential Anticipated Coefficients — gen_exponential_anticoef","text":"Generates Exponential Anticipated Coefficients Solves exponential link function mean = exp(beta0 + beta1 * x) mean = mean_low x = -1, mean = mean_high x = +1. Equivalently, solves set equations beta0 beta1: mean_low = exp(beta0 - beta1) mean_high = exp(beta0 + beta1)","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/gen_exponential_anticoef.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generates Exponential Anticipated Coefficients — gen_exponential_anticoef","text":"","code":"gen_exponential_anticoef(anticoef, mean_low, mean_high)"},{"path":"https://tylermorganwall.github.io/skpr/reference/gen_exponential_anticoef.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generates Exponential Anticipated Coefficients — gen_exponential_anticoef","text":"anticoef input anticipated coefficients mean_low low value mean value (= 1/rate) mean_high high value mean value (= 1/rate)","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/gen_exponential_anticoef.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generates Exponential Anticipated Coefficients — gen_exponential_anticoef","text":"Anticipated coefficients.","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/gen_momentsmatrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Generates the moment matrix — gen_momentsmatrix","title":"Generates the moment matrix — gen_momentsmatrix","text":"Returns number levels prior parameter","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/gen_momentsmatrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generates the moment matrix — gen_momentsmatrix","text":"","code":"gen_momentsmatrix(modelfactors, levelvector, classvector)"},{"path":"https://tylermorganwall.github.io/skpr/reference/gen_momentsmatrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generates the moment matrix — gen_momentsmatrix","text":"Returns vector consisting number levels preceeding parameter (including intercept)","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/gen_poisson_anticoef.html","id":null,"dir":"Reference","previous_headings":"","what":"Generates Poisson Anticipated Coefficients — gen_poisson_anticoef","title":"Generates Poisson Anticipated Coefficients — gen_poisson_anticoef","text":"Generates Poisson Anticipated Coefficients Solves Poisson link function mean = exp(beta0 + beta1 * x) mean = mean_low x = -1, mean = mean_high x = +1. Equivalently, solves set equations beta0 beta1: mean_low = exp(beta0 - beta1) mean_high = exp(beta0 + beta1)","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/gen_poisson_anticoef.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generates Poisson Anticipated Coefficients — gen_poisson_anticoef","text":"","code":"gen_poisson_anticoef(anticoef, mean_low, mean_high)"},{"path":"https://tylermorganwall.github.io/skpr/reference/gen_poisson_anticoef.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generates Poisson Anticipated Coefficients — gen_poisson_anticoef","text":"anticoef input anticipated coefficients proper length model matrix mean_low low value mean value mean_high high value mean value","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/gen_poisson_anticoef.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generates Poisson Anticipated Coefficients — gen_poisson_anticoef","text":"Anticipated coefficients.","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/generate_block_panel.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Block Panel — generate_block_panel","title":"Generate Block Panel — generate_block_panel","text":"Generate Block Panel","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/generate_block_panel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Block Panel — generate_block_panel","text":"","code":"generate_block_panel(any_htc)"},{"path":"https://tylermorganwall.github.io/skpr/reference/generate_block_panel.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Block Panel — generate_block_panel","text":"any_htc Factor number","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/generate_block_panel.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Block Panel — generate_block_panel","text":"Shiny UI","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/generate_factor_input_panel.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Factor Input Panel — generate_factor_input_panel","title":"Generate Factor Input Panel — generate_factor_input_panel","text":"Generate Factor Input Panel","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/generate_factor_input_panel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Factor Input Panel — generate_factor_input_panel","text":"","code":"generate_factor_input_panel(factor_n = 1, factor_input_cache = NULL)"},{"path":"https://tylermorganwall.github.io/skpr/reference/generate_factor_input_panel.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Factor Input Panel — generate_factor_input_panel","text":"factor_n Factor number","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/generate_factor_input_panel.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Factor Input Panel — generate_factor_input_panel","text":"Shiny UI","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/generate_noise_block.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Noise Block — generate_noise_block","title":"Generate Noise Block — generate_noise_block","text":"Generates noise added REML power calculation","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/generate_noise_block.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Noise Block — generate_noise_block","text":"","code":"generate_noise_block(noise, groups, blockstructure)"},{"path":"https://tylermorganwall.github.io/skpr/reference/generate_noise_block.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Noise Block — generate_noise_block","text":"Noise vector","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/generate_optimality_results.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Optimality Results — generate_optimality_results","title":"Generate Optimality Results — generate_optimality_results","text":"Generate Optimality Results","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/generate_optimality_results.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Optimality Results — generate_optimality_results","text":"","code":"generate_optimality_results(any_htc)"},{"path":"https://tylermorganwall.github.io/skpr/reference/generate_optimality_results.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Optimality Results — generate_optimality_results","text":"any_htc Factor number","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/generate_optimality_results.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Optimality Results — generate_optimality_results","text":"Shiny UI","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/genhypmatrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Hypothesis Matrix — genhypmatrix","title":"Generate Hypothesis Matrix — genhypmatrix","text":"Generates hypothesis matrix power calculation","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/genhypmatrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Hypothesis Matrix — genhypmatrix","text":"","code":"genhypmatrix(parameters, levels, g)"},{"path":"https://tylermorganwall.github.io/skpr/reference/genhypmatrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Hypothesis Matrix — genhypmatrix","text":"parameters Number parameters total model levels Number levels parameter interest g Number levels/parameters preceding parameter interest","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/genhypmatrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Hypothesis Matrix — genhypmatrix","text":"parameter matrix L isolating levels parameter interest","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/genparammatrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Parameter Matrix — genparammatrix","title":"Generate Parameter Matrix — genparammatrix","text":"Generates parameter matrix L isolate levels interest calculation power","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/genparammatrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Parameter Matrix — genparammatrix","text":"","code":"genparammatrix(parameters, levels, g)"},{"path":"https://tylermorganwall.github.io/skpr/reference/genparammatrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Parameter Matrix — genparammatrix","text":"parameters Number parameters total model. levels Number levels parameter interest g Number levels/parameters preceeding parameter interest","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/genparammatrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Parameter Matrix — genparammatrix","text":"parameter vector Q isolating levels parameter interest","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/get_attribute.html","id":null,"dir":"Reference","previous_headings":"","what":"Get attribute values — get_attribute","title":"Get attribute values — get_attribute","text":"Returns one underlying attributes used design generation/evaluation","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/get_attribute.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get attribute values — get_attribute","text":"","code":"get_attribute(output, attr = NULL, round = TRUE)"},{"path":"https://tylermorganwall.github.io/skpr/reference/get_attribute.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get attribute values — get_attribute","text":"output output either `gen_design()` `eval_design()`/`eval_design_mc()“ attr Default `NULL`. Return just specific value requested. Potential values `model.matrix` model used, `moments.matrix`, `variance.matrix`, `alias.matrix`, `correlation.matrix`, `model` model used evaluation/generation design. round Default `TRUE`. Rounds values smaller magnitude `1e-15“ `correlation.matrix` `alias.matrix` matrix attributes.","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/get_attribute.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get attribute values — get_attribute","text":"list attributes.","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/get_attribute.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get attribute values — get_attribute","text":"","code":"# We can extract the attributes of a design from either the output of `gen_design()` # or the output of `eval_design()`  factorialcoffee = expand.grid(cost = c(1, 2),                              type = as.factor(c(\"Kona\", \"Colombian\", \"Ethiopian\", \"Sumatra\")),                              size = as.factor(c(\"Short\", \"Grande\", \"Venti\")))  designcoffee = gen_design(factorialcoffee, ~cost + size + type, trials = 29,                          optimality = \"D\", repeats = 100)  #Extract a list of all attributes get_attribute(designcoffee) #> $model.matrix #>       (Intercept) cost      size1     size2      type1      type2     type3 #>  [1,]           1   -1 -0.7071068  1.224745 -0.5773503  1.6329932  0.000000 #>  [2,]           1    1  1.4142136  0.000000 -0.5773503 -0.8164966 -1.414214 #>  [3,]           1    1 -0.7071068 -1.224745 -0.5773503 -0.8164966  1.414214 #>  [4,]           1   -1 -0.7071068 -1.224745 -0.5773503  1.6329932  0.000000 #>  [5,]           1   -1  1.4142136  0.000000  1.7320508  0.0000000  0.000000 #>  [6,]           1   -1  1.4142136  0.000000 -0.5773503 -0.8164966 -1.414214 #>  [7,]           1   -1 -0.7071068 -1.224745 -0.5773503 -0.8164966 -1.414214 #>  [8,]           1    1 -0.7071068  1.224745 -0.5773503 -0.8164966 -1.414214 #>  [9,]           1   -1 -0.7071068 -1.224745  1.7320508  0.0000000  0.000000 #> [10,]           1    1  1.4142136  0.000000 -0.5773503 -0.8164966 -1.414214 #> [11,]           1    1 -0.7071068 -1.224745  1.7320508  0.0000000  0.000000 #> [12,]           1   -1  1.4142136  0.000000 -0.5773503  1.6329932  0.000000 #> [13,]           1   -1 -0.7071068 -1.224745 -0.5773503 -0.8164966  1.414214 #> [14,]           1    1 -0.7071068 -1.224745  1.7320508  0.0000000  0.000000 #> [15,]           1    1  1.4142136  0.000000 -0.5773503  1.6329932  0.000000 #> [16,]           1    1  1.4142136  0.000000 -0.5773503 -0.8164966  1.414214 #> [17,]           1    1 -0.7071068  1.224745  1.7320508  0.0000000  0.000000 #> [18,]           1   -1 -0.7071068  1.224745 -0.5773503 -0.8164966 -1.414214 #> [19,]           1    1  1.4142136  0.000000 -0.5773503 -0.8164966  1.414214 #> [20,]           1   -1 -0.7071068  1.224745  1.7320508  0.0000000  0.000000 #> [21,]           1   -1  1.4142136  0.000000  1.7320508  0.0000000  0.000000 #> [22,]           1   -1 -0.7071068  1.224745 -0.5773503 -0.8164966  1.414214 #> [23,]           1    1  1.4142136  0.000000 -0.5773503  1.6329932  0.000000 #> [24,]           1    1 -0.7071068  1.224745 -0.5773503 -0.8164966  1.414214 #> [25,]           1    1 -0.7071068 -1.224745 -0.5773503  1.6329932  0.000000 #> [26,]           1   -1  1.4142136  0.000000 -0.5773503 -0.8164966  1.414214 #> [27,]           1    1 -0.7071068  1.224745  1.7320508  0.0000000  0.000000 #> [28,]           1    1 -0.7071068  1.224745 -0.5773503  1.6329932  0.000000 #> [29,]           1    1 -0.7071068 -1.224745 -0.5773503 -0.8164966 -1.414214 #>  #> $moments.matrix #>             (Intercept)      cost size1 size2 type1 type2 type3 #> (Intercept)           1 0.0000000     0     0     0     0     0 #> cost                  0 0.3333333     0     0     0     0     0 #> size1                 0 0.0000000     1     0     0     0     0 #> size2                 0 0.0000000     0     1     0     0     0 #> type1                 0 0.0000000     0     0     1     0     0 #> type2                 0 0.0000000     0     0     0     1     0 #> type3                 0 0.0000000     0     0     0     0     1 #>  #> $variance.matrix #>       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13] #>  [1,]    1    0    0    0    0    0    0    0    0     0     0     0     0 #>  [2,]    0    1    0    0    0    0    0    0    0     0     0     0     0 #>  [3,]    0    0    1    0    0    0    0    0    0     0     0     0     0 #>  [4,]    0    0    0    1    0    0    0    0    0     0     0     0     0 #>  [5,]    0    0    0    0    1    0    0    0    0     0     0     0     0 #>  [6,]    0    0    0    0    0    1    0    0    0     0     0     0     0 #>  [7,]    0    0    0    0    0    0    1    0    0     0     0     0     0 #>  [8,]    0    0    0    0    0    0    0    1    0     0     0     0     0 #>  [9,]    0    0    0    0    0    0    0    0    1     0     0     0     0 #> [10,]    0    0    0    0    0    0    0    0    0     1     0     0     0 #> [11,]    0    0    0    0    0    0    0    0    0     0     1     0     0 #> [12,]    0    0    0    0    0    0    0    0    0     0     0     1     0 #> [13,]    0    0    0    0    0    0    0    0    0     0     0     0     1 #> [14,]    0    0    0    0    0    0    0    0    0     0     0     0     0 #> [15,]    0    0    0    0    0    0    0    0    0     0     0     0     0 #> [16,]    0    0    0    0    0    0    0    0    0     0     0     0     0 #> [17,]    0    0    0    0    0    0    0    0    0     0     0     0     0 #> [18,]    0    0    0    0    0    0    0    0    0     0     0     0     0 #> [19,]    0    0    0    0    0    0    0    0    0     0     0     0     0 #> [20,]    0    0    0    0    0    0    0    0    0     0     0     0     0 #> [21,]    0    0    0    0    0    0    0    0    0     0     0     0     0 #> [22,]    0    0    0    0    0    0    0    0    0     0     0     0     0 #> [23,]    0    0    0    0    0    0    0    0    0     0     0     0     0 #> [24,]    0    0    0    0    0    0    0    0    0     0     0     0     0 #> [25,]    0    0    0    0    0    0    0    0    0     0     0     0     0 #> [26,]    0    0    0    0    0    0    0    0    0     0     0     0     0 #> [27,]    0    0    0    0    0    0    0    0    0     0     0     0     0 #> [28,]    0    0    0    0    0    0    0    0    0     0     0     0     0 #> [29,]    0    0    0    0    0    0    0    0    0     0     0     0     0 #>       [,14] [,15] [,16] [,17] [,18] [,19] [,20] [,21] [,22] [,23] [,24] [,25] #>  [1,]     0     0     0     0     0     0     0     0     0     0     0     0 #>  [2,]     0     0     0     0     0     0     0     0     0     0     0     0 #>  [3,]     0     0     0     0     0     0     0     0     0     0     0     0 #>  [4,]     0     0     0     0     0     0     0     0     0     0     0     0 #>  [5,]     0     0     0     0     0     0     0     0     0     0     0     0 #>  [6,]     0     0     0     0     0     0     0     0     0     0     0     0 #>  [7,]     0     0     0     0     0     0     0     0     0     0     0     0 #>  [8,]     0     0     0     0     0     0     0     0     0     0     0     0 #>  [9,]     0     0     0     0     0     0     0     0     0     0     0     0 #> [10,]     0     0     0     0     0     0     0     0     0     0     0     0 #> [11,]     0     0     0     0     0     0     0     0     0     0     0     0 #> [12,]     0     0     0     0     0     0     0     0     0     0     0     0 #> [13,]     0     0     0     0     0     0     0     0     0     0     0     0 #> [14,]     1     0     0     0     0     0     0     0     0     0     0     0 #> [15,]     0     1     0     0     0     0     0     0     0     0     0     0 #> [16,]     0     0     1     0     0     0     0     0     0     0     0     0 #> [17,]     0     0     0     1     0     0     0     0     0     0     0     0 #> [18,]     0     0     0     0     1     0     0     0     0     0     0     0 #> [19,]     0     0     0     0     0     1     0     0     0     0     0     0 #> [20,]     0     0     0     0     0     0     1     0     0     0     0     0 #> [21,]     0     0     0     0     0     0     0     1     0     0     0     0 #> [22,]     0     0     0     0     0     0     0     0     1     0     0     0 #> [23,]     0     0     0     0     0     0     0     0     0     1     0     0 #> [24,]     0     0     0     0     0     0     0     0     0     0     1     0 #> [25,]     0     0     0     0     0     0     0     0     0     0     0     1 #> [26,]     0     0     0     0     0     0     0     0     0     0     0     0 #> [27,]     0     0     0     0     0     0     0     0     0     0     0     0 #> [28,]     0     0     0     0     0     0     0     0     0     0     0     0 #> [29,]     0     0     0     0     0     0     0     0     0     0     0     0 #>       [,26] [,27] [,28] [,29] #>  [1,]     0     0     0     0 #>  [2,]     0     0     0     0 #>  [3,]     0     0     0     0 #>  [4,]     0     0     0     0 #>  [5,]     0     0     0     0 #>  [6,]     0     0     0     0 #>  [7,]     0     0     0     0 #>  [8,]     0     0     0     0 #>  [9,]     0     0     0     0 #> [10,]     0     0     0     0 #> [11,]     0     0     0     0 #> [12,]     0     0     0     0 #> [13,]     0     0     0     0 #> [14,]     0     0     0     0 #> [15,]     0     0     0     0 #> [16,]     0     0     0     0 #> [17,]     0     0     0     0 #> [18,]     0     0     0     0 #> [19,]     0     0     0     0 #> [20,]     0     0     0     0 #> [21,]     0     0     0     0 #> [22,]     0     0     0     0 #> [23,]     0     0     0     0 #> [24,]     0     0     0     0 #> [25,]     0     0     0     0 #> [26,]     1     0     0     0 #> [27,]     0     1     0     0 #> [28,]     0     0     1     0 #> [29,]     0     0     0     1 #>  #> $alias.matrix #>             cost size1 size2 type1 type2 type3   cost:size1 cost:size2 #> (Intercept)    0     0     0     0     0     0  0.005324599  0.0000000 #> cost           1     0     0     0     0     0  0.078804069  0.0000000 #> size1          0     1     0     0     0     0  0.048192771  0.0000000 #> size2          0     0     1     0     0     0  0.000000000  0.1111111 #> type1          0     0     0     1     0     0 -0.304341723  0.0000000 #> type2          0     0     0     0     1     0  0.000000000  0.0000000 #> type3          0     0     0     0     0     1  0.000000000  0.0000000 #>              cost:type1 cost:type2 cost:type3 size1:type1 size2:type1 #> (Intercept) -0.03478014  0.0000000  0.0000000 -0.12173669   0.0000000 #> cost         0.06260425  0.0000000  0.0000000 -0.33200915   0.0000000 #> size1       -0.31479386  0.0000000  0.0000000 -0.06260425   0.0000000 #> size2        0.00000000  0.0000000  0.0000000  0.00000000   0.1924501 #> type1       -0.01204819  0.0000000  0.0000000 -0.11288150   0.0000000 #> type2        0.00000000  0.1428571  0.0000000  0.00000000   0.0000000 #> type3        0.00000000  0.0000000  0.1428571  0.00000000   0.0000000 #>             size1:type2 size2:type2 size1:type3 size2:type3 #> (Intercept)   0.0000000           0   0.0000000           0 #> cost          0.0000000           0   0.0000000           0 #> size1         0.0000000           0   0.0000000           0 #> size2         0.0000000           0   0.0000000           0 #> type1         0.0000000           0   0.0000000           0 #> type2         0.2020305           0   0.0000000           0 #> type3         0.0000000           0   0.2020305           0 #>  #> $correlation.matrix #>             cost     size1 size2      type1 type2 type3 #> cost  1.00000000 0.0000000     0 0.05776713     0     0 #> size1 0.00000000 1.0000000     0 0.15803160     0     0 #> size2 0.00000000 0.0000000     1 0.00000000     0     0 #> type1 0.05776713 0.1580316     0 1.00000000     0     0 #> type2 0.00000000 0.0000000     0 0.00000000     1     0 #> type3 0.00000000 0.0000000     0 0.00000000     0     1 #>  #> $model #> ~cost + size + type #> <environment: 0x55eee3a2e3d8> #>   #Get just one attribute get_attribute(designcoffee,\"model.matrix\") #>       (Intercept) cost      size1     size2      type1      type2     type3 #>  [1,]           1   -1 -0.7071068  1.224745 -0.5773503  1.6329932  0.000000 #>  [2,]           1    1  1.4142136  0.000000 -0.5773503 -0.8164966 -1.414214 #>  [3,]           1    1 -0.7071068 -1.224745 -0.5773503 -0.8164966  1.414214 #>  [4,]           1   -1 -0.7071068 -1.224745 -0.5773503  1.6329932  0.000000 #>  [5,]           1   -1  1.4142136  0.000000  1.7320508  0.0000000  0.000000 #>  [6,]           1   -1  1.4142136  0.000000 -0.5773503 -0.8164966 -1.414214 #>  [7,]           1   -1 -0.7071068 -1.224745 -0.5773503 -0.8164966 -1.414214 #>  [8,]           1    1 -0.7071068  1.224745 -0.5773503 -0.8164966 -1.414214 #>  [9,]           1   -1 -0.7071068 -1.224745  1.7320508  0.0000000  0.000000 #> [10,]           1    1  1.4142136  0.000000 -0.5773503 -0.8164966 -1.414214 #> [11,]           1    1 -0.7071068 -1.224745  1.7320508  0.0000000  0.000000 #> [12,]           1   -1  1.4142136  0.000000 -0.5773503  1.6329932  0.000000 #> [13,]           1   -1 -0.7071068 -1.224745 -0.5773503 -0.8164966  1.414214 #> [14,]           1    1 -0.7071068 -1.224745  1.7320508  0.0000000  0.000000 #> [15,]           1    1  1.4142136  0.000000 -0.5773503  1.6329932  0.000000 #> [16,]           1    1  1.4142136  0.000000 -0.5773503 -0.8164966  1.414214 #> [17,]           1    1 -0.7071068  1.224745  1.7320508  0.0000000  0.000000 #> [18,]           1   -1 -0.7071068  1.224745 -0.5773503 -0.8164966 -1.414214 #> [19,]           1    1  1.4142136  0.000000 -0.5773503 -0.8164966  1.414214 #> [20,]           1   -1 -0.7071068  1.224745  1.7320508  0.0000000  0.000000 #> [21,]           1   -1  1.4142136  0.000000  1.7320508  0.0000000  0.000000 #> [22,]           1   -1 -0.7071068  1.224745 -0.5773503 -0.8164966  1.414214 #> [23,]           1    1  1.4142136  0.000000 -0.5773503  1.6329932  0.000000 #> [24,]           1    1 -0.7071068  1.224745 -0.5773503 -0.8164966  1.414214 #> [25,]           1    1 -0.7071068 -1.224745 -0.5773503  1.6329932  0.000000 #> [26,]           1   -1  1.4142136  0.000000 -0.5773503 -0.8164966  1.414214 #> [27,]           1    1 -0.7071068  1.224745  1.7320508  0.0000000  0.000000 #> [28,]           1    1 -0.7071068  1.224745 -0.5773503  1.6329932  0.000000 #> [29,]           1    1 -0.7071068 -1.224745 -0.5773503 -0.8164966 -1.414214  # Extract from `eval_design()` output power_output = eval_design(designcoffee, model = ~cost + size + type,                           alpha = 0.05, detailedoutput = TRUE)  get_attribute(power_output,\"correlation.matrix\") #>             cost      size1      size2      type1      type2      type3 #> cost  1.00000000 0.00997807 0.01772574 0.02159185 0.03064609 0.05386824 #> size1 0.00997807 1.00000000 0.04386345 0.02576107 0.03656362 0.06426979 #> size2 0.01772574 0.04386345 1.00000000 0.04576376 0.06495416 0.11417333 #> type1 0.02159185 0.02576107 0.04576376 1.00000000 0.01022654 0.01797572 #> type2 0.03064609 0.03656362 0.06495416 0.01022654 1.00000000 0.02551359 #> type3 0.05386824 0.06426979 0.11417333 0.01797572 0.02551359 1.00000000"},{"path":"https://tylermorganwall.github.io/skpr/reference/get_block_groups.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate block structure lengths — get_block_groups","title":"Calculate block structure lengths — get_block_groups","text":"Calculate block structure lengths","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/get_block_groups.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate block structure lengths — get_block_groups","text":"","code":"get_block_groups(existing_block_structure)"},{"path":"https://tylermorganwall.github.io/skpr/reference/get_block_groups.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate block structure lengths — get_block_groups","text":"existing_block_structure character matrix rownames, split `.`","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/get_block_groups.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate block structure lengths — get_block_groups","text":"List numbers indicating split plot layer sizes","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/get_optimality.html","id":null,"dir":"Reference","previous_headings":"","what":"Get optimality values — get_optimality","title":"Get optimality values — get_optimality","text":"Returns list optimality values (one value particular). Note: choice contrast effect `G` efficiency value, `gen_design()` `eval_design()` default set different contrasts (`contr.simplex` vs `contr.sum`).","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/get_optimality.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get optimality values — get_optimality","text":"","code":"get_optimality(output, optimality = NULL, calc_g = FALSE)"},{"path":"https://tylermorganwall.github.io/skpr/reference/get_optimality.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get optimality values — get_optimality","text":"output output either gen_design eval_design/eval_design_mc. optimality Default `NULL`. Return just specific optimality requested. calc_g Default `FALSE`. Whether calculate g-efficiency.","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/get_optimality.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get optimality values — get_optimality","text":"dataframe optimality conditions. `D`, ``, `G` efficiencies (value 100). `T` trace information matrix, `E` minimum eigenvalue information matrix, `` average prediction variance, `Alias` trace alias matrix.","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/get_optimality.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get optimality values — get_optimality","text":"","code":"# We can extract the optimality of a design from either the output of `gen_design()` # or the output of `eval_design()`  factorialcoffee = expand.grid(cost = c(1, 2),                              type = as.factor(c(\"Kona\", \"Colombian\", \"Ethiopian\", \"Sumatra\")),                              size = as.factor(c(\"Short\", \"Grande\", \"Venti\")))  designcoffee = gen_design(factorialcoffee, ~cost + size + type, trials = 29,                          optimality = \"D\", repeats = 100)  #Extract a list of all attributes get_optimality(designcoffee) #>          D         I        A            G   T        E    Alias #> 1 99.09996 0.2224214 98.21557 Not Computed 203 22.79472 6.519097  #Get just one attribute get_optimality(designcoffee,\"D\") #>          D #> 1 99.09996  # Extract from `eval_design()` output power_output = eval_design(designcoffee, model = ~cost + size + type,                           alpha = 0.05, detailedoutput = TRUE)  get_optimality(power_output) #>          D         I        A        G   T        E    Alias #> 1 99.09996 0.2224214 98.21557 98.09173 203 22.79472 19.72452"},{"path":"https://tylermorganwall.github.io/skpr/reference/get_power_curve_output.html","id":null,"dir":"Reference","previous_headings":"","what":"Get Power Curve Warnings and Errors — get_power_curve_output","title":"Get Power Curve Warnings and Errors — get_power_curve_output","text":"Gets warnings errors `calculate_power_curves()` output.","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/get_power_curve_output.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get Power Curve Warnings and Errors — get_power_curve_output","text":"","code":"get_power_curve_output(power_curve)"},{"path":"https://tylermorganwall.github.io/skpr/reference/get_power_curve_output.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get Power Curve Warnings and Errors — get_power_curve_output","text":"power_curve output `calculate_power_curves()`","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/get_power_curve_output.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get Power Curve Warnings and Errors — get_power_curve_output","text":"list data.frames containing warning/error information","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/get_power_curve_output.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get Power Curve Warnings and Errors — get_power_curve_output","text":"","code":"#Generate sample if(skpr:::run_documentation()) { calculate_power_curves(trials=seq(50,150,by=20),                       candidateset = expand.grid(x=c(-1,1),y=c(-1,1)),                       model = ~.,                       effectsize = list(c(0.5,0.9),c(0.6,0.9)),                       eval_function = eval_design_mc,                       eval_args = list(nsim = 100, glmfamily = \"binomial\")) }  #>      parameter               type power trials effectsize_low effectsize_high #> 1  (Intercept)    effect.power.mc  0.85     50            0.5             0.9 #> 2            x    effect.power.mc  0.85     50            0.5             0.9 #> 3            y    effect.power.mc  0.70     50            0.5             0.9 #> 4  (Intercept) parameter.power.mc  0.85     50            0.5             0.9 #> 5            x parameter.power.mc  0.85     50            0.5             0.9 #> 6            y parameter.power.mc  0.70     50            0.5             0.9 #> 7  (Intercept)    effect.power.mc  0.96     70            0.5             0.9 #> 8            x    effect.power.mc  0.95     70            0.5             0.9 #> 9            y    effect.power.mc  0.94     70            0.5             0.9 #> 10 (Intercept) parameter.power.mc  0.96     70            0.5             0.9 #> 11           x parameter.power.mc  0.95     70            0.5             0.9 #> 12           y parameter.power.mc  0.94     70            0.5             0.9 #> 13 (Intercept)    effect.power.mc  0.99     90            0.5             0.9 #> 14           x    effect.power.mc  1.00     90            0.5             0.9 #> 15           y    effect.power.mc  0.99     90            0.5             0.9 #> 16 (Intercept) parameter.power.mc  0.99     90            0.5             0.9 #> 17           x parameter.power.mc  1.00     90            0.5             0.9 #> 18           y parameter.power.mc  0.99     90            0.5             0.9 #> 19 (Intercept)    effect.power.mc  0.99    110            0.5             0.9 #> 20           x    effect.power.mc  1.00    110            0.5             0.9 #> 21           y    effect.power.mc  1.00    110            0.5             0.9 #> 22 (Intercept) parameter.power.mc  0.99    110            0.5             0.9 #> 23           x parameter.power.mc  1.00    110            0.5             0.9 #> 24           y parameter.power.mc  1.00    110            0.5             0.9 #> 25 (Intercept)    effect.power.mc  1.00    130            0.5             0.9 #> 26           x    effect.power.mc  1.00    130            0.5             0.9 #> 27           y    effect.power.mc  1.00    130            0.5             0.9 #> 28 (Intercept) parameter.power.mc  1.00    130            0.5             0.9 #> 29           x parameter.power.mc  1.00    130            0.5             0.9 #> 30           y parameter.power.mc  1.00    130            0.5             0.9 #> 31 (Intercept)    effect.power.mc  1.00    150            0.5             0.9 #> 32           x    effect.power.mc  1.00    150            0.5             0.9 #> 33           y    effect.power.mc  1.00    150            0.5             0.9 #> 34 (Intercept) parameter.power.mc  1.00    150            0.5             0.9 #> 35           x parameter.power.mc  1.00    150            0.5             0.9 #> 36           y parameter.power.mc  1.00    150            0.5             0.9 #> 37 (Intercept)    effect.power.mc  0.89     50            0.6             0.9 #> 38           x    effect.power.mc  0.65     50            0.6             0.9 #> 39           y    effect.power.mc  0.60     50            0.6             0.9 #> 40 (Intercept) parameter.power.mc  0.89     50            0.6             0.9 #> 41           x parameter.power.mc  0.65     50            0.6             0.9 #> 42           y parameter.power.mc  0.60     50            0.6             0.9 #> 43 (Intercept)    effect.power.mc  0.98     70            0.6             0.9 #> 44           x    effect.power.mc  0.76     70            0.6             0.9 #> 45           y    effect.power.mc  0.81     70            0.6             0.9 #> 46 (Intercept) parameter.power.mc  0.98     70            0.6             0.9 #> 47           x parameter.power.mc  0.76     70            0.6             0.9 #> 48           y parameter.power.mc  0.81     70            0.6             0.9 #> 49 (Intercept)    effect.power.mc  1.00     90            0.6             0.9 #> 50           x    effect.power.mc  0.92     90            0.6             0.9 #> 51           y    effect.power.mc  0.95     90            0.6             0.9 #> 52 (Intercept) parameter.power.mc  1.00     90            0.6             0.9 #> 53           x parameter.power.mc  0.92     90            0.6             0.9 #> 54           y parameter.power.mc  0.95     90            0.6             0.9 #> 55 (Intercept)    effect.power.mc  1.00    110            0.6             0.9 #> 56           x    effect.power.mc  0.99    110            0.6             0.9 #> 57           y    effect.power.mc  0.98    110            0.6             0.9 #> 58 (Intercept) parameter.power.mc  1.00    110            0.6             0.9 #> 59           x parameter.power.mc  0.99    110            0.6             0.9 #> 60           y parameter.power.mc  0.98    110            0.6             0.9 #> 61 (Intercept)    effect.power.mc  1.00    130            0.6             0.9 #> 62           x    effect.power.mc  0.99    130            0.6             0.9 #> 63           y    effect.power.mc  0.98    130            0.6             0.9 #> 64 (Intercept) parameter.power.mc  1.00    130            0.6             0.9 #> 65           x parameter.power.mc  0.99    130            0.6             0.9 #> 66           y parameter.power.mc  0.98    130            0.6             0.9 #> 67 (Intercept)    effect.power.mc  1.00    150            0.6             0.9 #> 68           x    effect.power.mc  0.99    150            0.6             0.9 #> 69           y    effect.power.mc  0.97    150            0.6             0.9 #> 70 (Intercept) parameter.power.mc  1.00    150            0.6             0.9 #> 71           x parameter.power.mc  0.99    150            0.6             0.9 #> 72           y parameter.power.mc  0.97    150            0.6             0.9 #>    random_seed #> 1          123 #> 2          123 #> 3          123 #> 4          123 #> 5          123 #> 6          123 #> 7          123 #> 8          123 #> 9          123 #> 10         123 #> 11         123 #> 12         123 #> 13         123 #> 14         123 #> 15         123 #> 16         123 #> 17         123 #> 18         123 #> 19         123 #> 20         123 #> 21         123 #> 22         123 #> 23         123 #> 24         123 #> 25         123 #> 26         123 #> 27         123 #> 28         123 #> 29         123 #> 30         123 #> 31         123 #> 32         123 #> 33         123 #> 34         123 #> 35         123 #> 36         123 #> 37         123 #> 38         123 #> 39         123 #> 40         123 #> 41         123 #> 42         123 #> 43         123 #> 44         123 #> 45         123 #> 46         123 #> 47         123 #> 48         123 #> 49         123 #> 50         123 #> 51         123 #> 52         123 #> 53         123 #> 54         123 #> 55         123 #> 56         123 #> 57         123 #> 58         123 #> 59         123 #> 60         123 #> 61         123 #> 62         123 #> 63         123 #> 64         123 #> 65         123 #> 66         123 #> 67         123 #> 68         123 #> 69         123 #> 70         123 #> 71         123 #> 72         123 #> Power curve generation captured the following warning/error messages: #> Function   | Type | N | Message #> Evaluation | Warn | 1 | Message: 'skpr: Partial or complete separation likely detected in the binomial Monte Carlo simulation. Increase the number of runs in the design or decrease the number of model parameters to improve power.'"},{"path":"https://tylermorganwall.github.io/skpr/reference/is_intralayer_interaction.html","id":null,"dir":"Reference","previous_headings":"","what":"Layer Interaction — is_intralayer_interaction","title":"Layer Interaction — is_intralayer_interaction","text":"Determines factor intra-layer interaction","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/is_intralayer_interaction.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Layer Interaction — is_intralayer_interaction","text":"","code":"is_intralayer_interaction(design, model, split_layers)"},{"path":"https://tylermorganwall.github.io/skpr/reference/is_intralayer_interaction.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Layer Interaction — is_intralayer_interaction","text":"design design matrix model model split_layers layer split plots main effect term","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/is_intralayer_interaction.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Layer Interaction — is_intralayer_interaction","text":"List booleans subplot strata layer","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/is_rendering_in_knitr.html","id":null,"dir":"Reference","previous_headings":"","what":"Determines if rendering in knitr — is_rendering_in_knitr","title":"Determines if rendering in knitr — is_rendering_in_knitr","text":"Determines rendering knitr","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/is_rendering_in_knitr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Determines if rendering in knitr — is_rendering_in_knitr","text":"","code":"is_rendering_in_knitr()"},{"path":"https://tylermorganwall.github.io/skpr/reference/is_rendering_in_knitr.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Determines if rendering in knitr — is_rendering_in_knitr","text":"boolean","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/normalize_design.html","id":null,"dir":"Reference","previous_headings":"","what":"Normalize Design — normalize_design","title":"Normalize Design — normalize_design","text":"Normalizes numeric columns design -1 1. important model interaction polynomial terms, terms can introduce multi-collinearity standardizing numeric columns can reduce problem. Normalizes numeric columns design -1 1. important model interaction polynomial terms, terms can introduce multi-collinearity standardizing numeric columns can reduce problem.","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/normalize_design.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Normalize Design — normalize_design","text":"","code":"normalize_design(design, augmented = NULL)  normalize_design(design, augmented = NULL)"},{"path":"https://tylermorganwall.github.io/skpr/reference/normalize_design.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Normalize Design — normalize_design","text":"design design matrix. augmented Default `NULL`. ","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/normalize_design.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Normalize Design — normalize_design","text":"Normalized design matrix Normalized run matrix","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/normalize_design.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Normalize Design — normalize_design","text":"","code":"#Normalize a design if(skpr:::run_documentation()) { cand_set = expand.grid(temp = c(100,300,500),                       altitude = c(10000,20000),                       offset = seq(-10,-5,by=1),                       type = c(\"A\",\"B\", \"C\")) design = gen_design(cand_set, ~., 24)  #Un-normalized design design } #>    temp altitude offset type #> 1   100    10000    -10    C #> 2   500    20000     -5    A #> 3   500    20000    -10    C #> 4   100    10000     -5    C #> 5   500    10000     -5    A #> 6   500    20000    -10    B #> 7   500    20000     -5    C #> 8   100    20000     -5    A #> 9   100    20000    -10    C #> 10  500    20000     -5    B #> 11  100    20000     -5    C #> 12  500    10000    -10    C #> 13  100    10000    -10    B #> 14  100    10000     -5    A #> 15  100    20000    -10    A #> 16  500    10000     -5    C #> 17  500    10000    -10    B #> 18  500    20000    -10    A #> 19  100    10000    -10    A #> 20  100    20000     -5    B #> 21  500    10000    -10    A #> 22  100    20000    -10    B #> 23  100    10000     -5    B #> 24  500    10000     -5    B if(skpr:::run_documentation()) { #Normalized design normalize_design(design) } #>    temp altitude offset type #> 1    -1       -1     -1    C #> 2     1        1      1    A #> 3     1        1     -1    C #> 4    -1       -1      1    C #> 5     1       -1      1    A #> 6     1        1     -1    B #> 7     1        1      1    C #> 8    -1        1      1    A #> 9    -1        1     -1    C #> 10    1        1      1    B #> 11   -1        1      1    C #> 12    1       -1     -1    C #> 13   -1       -1     -1    B #> 14   -1       -1      1    A #> 15   -1        1     -1    A #> 16    1       -1      1    C #> 17    1       -1     -1    B #> 18    1        1     -1    A #> 19   -1       -1     -1    A #> 20   -1        1      1    B #> 21    1       -1     -1    A #> 22   -1        1     -1    B #> 23   -1       -1      1    B #> 24    1       -1      1    B"},{"path":"https://tylermorganwall.github.io/skpr/reference/parameterpower.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculates parameter power — parameterpower","title":"Calculates parameter power — parameterpower","text":"Calculates parameter power","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/parameterpower.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculates parameter power — parameterpower","text":"","code":"parameterpower(   RunMatrix,   levelvector = NULL,   anticoef,   alpha,   vinv = NULL,   degrees = NULL,   parameter_names )"},{"path":"https://tylermorganwall.github.io/skpr/reference/parameterpower.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculates parameter power — parameterpower","text":"RunMatrix run matrix levelvector number levels parameter (1st always intercept) anticoef anticipated coefficients alpha specified type-error vinv V inverse matrix","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/parameterpower.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculates parameter power — parameterpower","text":"parameter power parameters","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/permutations.html","id":null,"dir":"Reference","previous_headings":"","what":"Permutations — permutations","title":"Permutations — permutations","text":"Return permutations","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/permutations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Permutations — permutations","text":"","code":"permutations(n)"},{"path":"https://tylermorganwall.github.io/skpr/reference/permutations.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Permutations — permutations","text":"n Number elements permute","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/permutations.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Permutations — permutations","text":"Matrix permuted element ids","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/pipe.html","id":null,"dir":"Reference","previous_headings":"","what":"re-export magrittr pipe operator — %>%","title":"re-export magrittr pipe operator — %>%","text":"re-export magrittr pipe operator","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/plot_correlations.html","id":null,"dir":"Reference","previous_headings":"","what":"Plots design diagnostics — plot_correlations","title":"Plots design diagnostics — plot_correlations","text":"Plots design diagnostics","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/plot_correlations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plots design diagnostics — plot_correlations","text":"","code":"plot_correlations(   genoutput,   model = NULL,   customcolors = NULL,   pow = 2,   custompar = NULL,   standardize = TRUE,   plot = TRUE )"},{"path":"https://tylermorganwall.github.io/skpr/reference/plot_correlations.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plots design diagnostics — plot_correlations","text":"genoutput output either gen_design eval_design/eval_design_mc model Default `NULL`. Defaults model used generating/evaluating design, augmented 2-factor interactions. specified, override default model used generate/evaluate design. customcolors vector colors customizing appearance colormap pow Default 2. interaction level correlation map showing. custompar Default NULL. Custom parameters pass `par` function base R plotting. standardize Default `TRUE`. Whether standardize (scale -1 1 center) continuous numeric columns. standardizing numeric columns can increase multi-collinearity (predictors correlated predictors model). plot Default `TRUE`. `FALSE`, return correlation matrix.","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/plot_correlations.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plots design diagnostics — plot_correlations","text":"Silently returns correlation matrix proper row column names.","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/plot_correlations.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plots design diagnostics — plot_correlations","text":"","code":"#We can pass either the output of gen_design or eval_design to plot_correlations #in order to obtain the correlation map. Passing the output of eval_design is useful #if you want to plot the correlation map from an externally generated design.  #First generate the design:  candidatelist = expand.grid(cost = c(15000, 20000), year = c(\"2001\", \"2002\", \"2003\", \"2004\"),                            type = c(\"SUV\", \"Sedan\", \"Hybrid\")) cardesign = gen_design(candidatelist, ~(cost+type+year)^2, 30) plot_correlations(cardesign)   #We can also increase the level of interactions that are shown by default.  plot_correlations(cardesign, pow = 3)   #You can also pass in a custom color map. plot_correlations(cardesign, customcolors = c(\"blue\", \"grey\", \"red\"))  plot_correlations(cardesign, customcolors = c(\"blue\", \"green\", \"yellow\", \"orange\", \"red\"))"},{"path":"https://tylermorganwall.github.io/skpr/reference/plot_fds.html","id":null,"dir":"Reference","previous_headings":"","what":"Fraction of Design Space Plot — plot_fds","title":"Fraction of Design Space Plot — plot_fds","text":"Creates fraction design space plot","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/plot_fds.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fraction of Design Space Plot — plot_fds","text":"","code":"plot_fds(   genoutput,   model = NULL,   continuouslength = 1001,   plot = TRUE,   sample_size = 10000,   yaxis_max = NULL,   description = \"Fraction of Design Space\" )"},{"path":"https://tylermorganwall.github.io/skpr/reference/plot_fds.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fraction of Design Space Plot — plot_fds","text":"genoutput design, output power evaluation functions. can also list several designs, result plotted row (easy comparison). model Default `NULL`. model, `NULL` defaults model used `eval_design` `gen_design`. continuouslength Default `11`. precision continuous variables. Decrease faster (less precise) plotting. plot Default `TRUE`. Whether plot FDS, just calculate cumulative distribution function. sample_size Default `10000`. Number samples take design space. yaxis_max Default `NULL`. Manually set maximum value prediction variance. description Default `Fraction Design Space`. description add plot. vector multiple designs passed genoutput, description plot.","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/plot_fds.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fraction of Design Space Plot — plot_fds","text":"Plots design diagnostics, invisibly returns vector values representing fraction design space plot. multiple designs passed, return list FDS vectors.","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/plot_fds.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fraction of Design Space Plot — plot_fds","text":"","code":"#We can pass either the output of gen_design or eval_design to plot_correlations #in order to obtain the correlation map. Passing the output of eval_design is useful #if you want to plot the correlation map from an externally generated design.  #First generate the design:  candidatelist = expand.grid(X1 = c(1, -1), X2 = c(1, -1))  design = gen_design(candidatelist, ~(X1 + X2), 15)  plot_fds(design)"},{"path":"https://tylermorganwall.github.io/skpr/reference/potential_permuted_factors.html","id":null,"dir":"Reference","previous_headings":"","what":"Find potential permuted interactions — potential_permuted_factors","title":"Find potential permuted interactions — potential_permuted_factors","text":"Returns permuted interactions","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/potential_permuted_factors.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find potential permuted interactions — potential_permuted_factors","text":"","code":"potential_permuted_factors(x)"},{"path":"https://tylermorganwall.github.io/skpr/reference/potential_permuted_factors.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find potential permuted interactions — potential_permuted_factors","text":"x character vector interaction terms","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/potential_permuted_factors.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find potential permuted interactions — potential_permuted_factors","text":"character vector potential interaction terms","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/print.skpr_eval_output.html","id":null,"dir":"Reference","previous_headings":"","what":"Print evaluation information — print.skpr_eval_output","title":"Print evaluation information — print.skpr_eval_output","text":"Prints design evaluation information data.frame power values Note: options(\"skpr.ANSI\") `NULL` `TRUE`, ANSI codes used printing prettify output. `FALSE`, ASCII used.","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/print.skpr_eval_output.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print evaluation information — print.skpr_eval_output","text":"","code":"# S3 method for class 'skpr_eval_output' print(x, ...)"},{"path":"https://tylermorganwall.github.io/skpr/reference/print.skpr_eval_output.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print evaluation information — print.skpr_eval_output","text":"x x evaluation functions skpr ... Additional arguments.","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/print.skpr_eval_output.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Print evaluation information — print.skpr_eval_output","text":"","code":"#Generate/evaluate a design and print its information factorialcoffee = expand.grid(cost = c(1, 2),                               type = as.factor(c(\"Kona\", \"Colombian\", \"Ethiopian\", \"Sumatra\")),                               size = as.factor(c(\"Short\", \"Grande\", \"Venti\")))  designcoffee = gen_design(factorialcoffee,                          ~cost + size + type, trials = 29, optimality = \"D\", repeats = 100)  eval_design(designcoffee) #>      parameter            type     power #> 1  (Intercept)    effect.power 0.9990689 #> 2         cost    effect.power 0.9991530 #> 3         size    effect.power 0.9522717 #> 4         type    effect.power 0.9907584 #> 5  (Intercept) parameter.power 0.9990689 #> 6         cost parameter.power 0.9991530 #> 7        size1 parameter.power 0.9443775 #> 8        size2 parameter.power 0.9443775 #> 9        type1 parameter.power 0.8339422 #> 10       type2 parameter.power 0.8339422 #> 11       type3 parameter.power 0.8339422 #> ============Evaluation Info============= #> • Alpha = 0.05 • Trials = 29 • Blocked = FALSE  #> • Evaluating Model = ~cost + size + type  #> • Anticipated Coefficients = c(1, 1, 1, -1, 1, -1, 1)  #> • Contrasts = `contr.sum`  #> • Parameter Analysis Method = `lm(...)`  #> • Effect Analysis Method = `car::Anova(fit, type = \"III\")`"},{"path":"https://tylermorganwall.github.io/skpr/reference/print.skpr_power_curve_output.html","id":null,"dir":"Reference","previous_headings":"","what":"Print evaluation information — print.skpr_power_curve_output","title":"Print evaluation information — print.skpr_power_curve_output","text":"Prints design evaluation information data.frame power values Note: options(\"skpr.ANSI\") `NULL` `TRUE`, ANSI codes used printing prettify output. `FALSE`, ASCII used.","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/print.skpr_power_curve_output.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print evaluation information — print.skpr_power_curve_output","text":"","code":"# S3 method for class 'skpr_power_curve_output' print(x, ...)"},{"path":"https://tylermorganwall.github.io/skpr/reference/print.skpr_power_curve_output.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print evaluation information — print.skpr_power_curve_output","text":"x x evaluation functions skpr ... Additional arguments.","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/print.skpr_power_curve_output.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Print evaluation information — print.skpr_power_curve_output","text":"","code":"#Generate/evaluate a design and print its information factorialcoffee = expand.grid(cost = c(1, 2),                               type = as.factor(c(\"Kona\",                                                  \"Colombian\",                                                  \"Ethiopian\",                                                  \"Sumatra\")),                               size = as.factor(c(\"Short\",                                                  \"Grande\",                                                  \"Venti\")))  coffee_curves = calculate_power_curves(candidateset = factorialcoffee,                                       model = ~(cost + size + type)^2,                                       trials = 30:40, plot_results = FALSE) coffee_curves #>       parameter            type     power trials effectsize random_seed #> 1   (Intercept)    effect.power 0.6799517     30          1         123 #> 2          cost    effect.power 0.6799517     30          1         123 #> 3          size    effect.power 0.3767867     30          1         123 #> 4          type    effect.power 0.4478528     30          1         123 #> 5     cost:size    effect.power 0.3767867     30          1         123 #> 6     cost:type    effect.power 0.4478528     30          1         123 #> 7     size:type    effect.power 0.5799045     30          1         123 #> 8   (Intercept) parameter.power 0.6799517     30          1         123 #> 9          cost parameter.power 0.6799517     30          1         123 #> 10        size1 parameter.power 0.4020228     30          1         123 #> 11        size2 parameter.power 0.4020228     30          1         123 #> 12        type1 parameter.power 0.2809834     30          1         123 #> 13        type2 parameter.power 0.2809834     30          1         123 #> 14        type3 parameter.power 0.2961708     30          1         123 #> 15   cost:size1 parameter.power 0.4020228     30          1         123 #> 16   cost:size2 parameter.power 0.4020228     30          1         123 #> 17   cost:type1 parameter.power 0.2809834     30          1         123 #> 18   cost:type2 parameter.power 0.2809834     30          1         123 #> 19   cost:type3 parameter.power 0.2961708     30          1         123 #> 20  size1:type1 parameter.power 0.1750731     30          1         123 #> 21  size2:type1 parameter.power 0.1605014     30          1         123 #> 22  size1:type2 parameter.power 0.1605014     30          1         123 #> 23  size2:type2 parameter.power 0.1750731     30          1         123 #> 24  size1:type3 parameter.power 0.1645291     30          1         123 #> 25  size2:type3 parameter.power 0.1820507     30          1         123 #> 26  (Intercept)    effect.power 0.6957588     31          1         123 #> 27         cost    effect.power 0.6957588     31          1         123 #> 28         size    effect.power 0.3857370     31          1         123 #> 29         type    effect.power 0.4638559     31          1         123 #> 30    cost:size    effect.power 0.3857370     31          1         123 #> 31    cost:type    effect.power 0.4638559     31          1         123 #> 32    size:type    effect.power 0.6014444     31          1         123 #> 33  (Intercept) parameter.power 0.6957588     31          1         123 #> 34         cost parameter.power 0.6957588     31          1         123 #> 35        size1 parameter.power 0.4115382     31          1         123 #> 36        size2 parameter.power 0.4115382     31          1         123 #> 37        type1 parameter.power 0.2864825     31          1         123 #> 38        type2 parameter.power 0.3006589     31          1         123 #> 39        type3 parameter.power 0.3017406     31          1         123 #> 40   cost:size1 parameter.power 0.4115382     31          1         123 #> 41   cost:size2 parameter.power 0.4115382     31          1         123 #> 42   cost:type1 parameter.power 0.2864825     31          1         123 #> 43   cost:type2 parameter.power 0.3006589     31          1         123 #> 44   cost:type3 parameter.power 0.3017406     31          1         123 #> 45  size1:type1 parameter.power 0.1627166     31          1         123 #> 46  size2:type1 parameter.power 0.1627166     31          1         123 #> 47  size1:type2 parameter.power 0.1847808     31          1         123 #> 48  size2:type2 parameter.power 0.1847808     31          1         123 #> 49  size1:type3 parameter.power 0.1852767     31          1         123 #> 50  size2:type3 parameter.power 0.1667419     31          1         123 #> 51  (Intercept)    effect.power 0.7217557     32          1         123 #> 52         cost    effect.power 0.7114742     32          1         123 #> 53         size    effect.power 0.4056223     32          1         123 #> 54         type    effect.power 0.4940241     32          1         123 #> 55    cost:size    effect.power 0.4026865     32          1         123 #> 56    cost:type    effect.power 0.4843502     32          1         123 #> 57    size:type    effect.power 0.6174756     32          1         123 #> 58  (Intercept) parameter.power 0.7217557     32          1         123 #> 59         cost parameter.power 0.7114742     32          1         123 #> 60        size1 parameter.power 0.4220396     32          1         123 #> 61        size2 parameter.power 0.4380334     32          1         123 #> 62        type1 parameter.power 0.3134382     32          1         123 #> 63        type2 parameter.power 0.3087049     32          1         123 #> 64        type3 parameter.power 0.3073138     32          1         123 #> 65   cost:size1 parameter.power 0.4184315     32          1         123 #> 66   cost:size2 parameter.power 0.4313056     32          1         123 #> 67   cost:type1 parameter.power 0.3059611     32          1         123 #> 68   cost:type2 parameter.power 0.3059611     32          1         123 #> 69   cost:type3 parameter.power 0.3069861     32          1         123 #> 70  size1:type1 parameter.power 0.1828776     32          1         123 #> 71  size2:type1 parameter.power 0.1820009     32          1         123 #> 72  size1:type2 parameter.power 0.1863350     32          1         123 #> 73  size2:type2 parameter.power 0.1699729     32          1         123 #> 74  size1:type3 parameter.power 0.1685079     32          1         123 #> 75  size2:type3 parameter.power 0.1875840     32          1         123 #> 76  (Intercept)    effect.power 0.7438833     33          1         123 #> 77         cost    effect.power 0.7252330     33          1         123 #> 78         size    effect.power 0.4284742     33          1         123 #> 79         type    effect.power 0.5178300     33          1         123 #> 80    cost:size    effect.power 0.4213750     33          1         123 #> 81    cost:type    effect.power 0.5011963     33          1         123 #> 82    size:type    effect.power 0.6881126     33          1         123 #> 83  (Intercept) parameter.power 0.7438833     33          1         123 #> 84         cost parameter.power 0.7252330     33          1         123 #> 85        size1 parameter.power 0.4489231     33          1         123 #> 86        size2 parameter.power 0.4475224     33          1         123 #> 87        type1 parameter.power 0.3211385     33          1         123 #> 88        type2 parameter.power 0.3151385     33          1         123 #> 89        type3 parameter.power 0.3159419     33          1         123 #> 90   cost:size1 parameter.power 0.4392456     33          1         123 #> 91   cost:size2 parameter.power 0.4392456     33          1         123 #> 92   cost:type1 parameter.power 0.3106586     33          1         123 #> 93   cost:type2 parameter.power 0.3106586     33          1         123 #> 94   cost:type3 parameter.power 0.3106586     33          1         123 #> 95  size1:type1 parameter.power 0.1858696     33          1         123 #> 96  size2:type1 parameter.power 0.1728170     33          1         123 #> 97  size1:type2 parameter.power 0.1849216     33          1         123 #> 98  size2:type2 parameter.power 0.1840955     33          1         123 #> 99  size1:type3 parameter.power 0.1710522     33          1         123 #> 100 size2:type3 parameter.power 0.1895420     33          1         123 #> 101 (Intercept)    effect.power 0.7569160     34          1         123 #> 102        cost    effect.power 0.7376450     34          1         123 #> 103        size    effect.power 0.4313363     34          1         123 #> 104        type    effect.power 0.5390681     34          1         123 #> 105   cost:size    effect.power 0.4260546     34          1         123 #> 106   cost:type    effect.power 0.5185534     34          1         123 #> 107   size:type    effect.power 0.6984918     34          1         123 #> 108 (Intercept) parameter.power 0.7569160     34          1         123 #> 109        cost parameter.power 0.7376450     34          1         123 #> 110       size1 parameter.power 0.4515893     34          1         123 #> 111       size2 parameter.power 0.4545162     34          1         123 #> 112       type1 parameter.power 0.3273055     34          1         123 #> 113       type2 parameter.power 0.3308352     34          1         123 #> 114       type3 parameter.power 0.3553993     34          1         123 #> 115  cost:size1 parameter.power 0.4464771     34          1         123 #> 116  cost:size2 parameter.power 0.4464771     34          1         123 #> 117  cost:type1 parameter.power 0.3149170     34          1         123 #> 118  cost:type2 parameter.power 0.3149170     34          1         123 #> 119  cost:type3 parameter.power 0.3315543     34          1         123 #> 120 size1:type1 parameter.power 0.1883277     34          1         123 #> 121 size2:type1 parameter.power 0.1744749     34          1         123 #> 122 size1:type2 parameter.power 0.1748534     34          1         123 #> 123 size2:type2 parameter.power 0.1896316     34          1         123 #> 124 size1:type3 parameter.power 0.1979767     34          1         123 #> 125 size2:type3 parameter.power 0.1994969     34          1         123 #> 126 (Intercept)    effect.power 0.7565659     35          1         123 #> 127        cost    effect.power 0.7500965     35          1         123 #> 128        size    effect.power 0.4717278     35          1         123 #> 129        type    effect.power 0.5434100     35          1         123 #> 130   cost:size    effect.power 0.4438808     35          1         123 #> 131   cost:type    effect.power 0.5352030     35          1         123 #> 132   size:type    effect.power 0.7488180     35          1         123 #> 133 (Intercept) parameter.power 0.7565659     35          1         123 #> 134        cost parameter.power 0.7500965     35          1         123 #> 135       size1 parameter.power 0.4720082     35          1         123 #> 136       size2 parameter.power 0.4891384     35          1         123 #> 137       type1 parameter.power 0.3212784     35          1         123 #> 138       type2 parameter.power 0.3371426     35          1         123 #> 139       type3 parameter.power 0.3525940     35          1         123 #> 140  cost:size1 parameter.power 0.4536851     35          1         123 #> 141  cost:size2 parameter.power 0.4664493     35          1         123 #> 142  cost:type1 parameter.power 0.3190901     35          1         123 #> 143  cost:type2 parameter.power 0.3356799     35          1         123 #> 144  cost:type3 parameter.power 0.3356799     35          1         123 #> 145 size1:type1 parameter.power 0.1759507     35          1         123 #> 146 size2:type1 parameter.power 0.2003241     35          1         123 #> 147 size1:type2 parameter.power 0.2039876     35          1         123 #> 148 size2:type2 parameter.power 0.2082862     35          1         123 #> 149 size1:type3 parameter.power 0.1955240     35          1         123 #> 150 size2:type3 parameter.power 0.1972935     35          1         123 #> 151 (Intercept)    effect.power 0.7964338     36          1         123 #> 152        cost    effect.power 0.7627026     36          1         123 #> 153        size    effect.power 0.4884360     36          1         123 #> 154        type    effect.power 0.5903243     36          1         123 #> 155   cost:size    effect.power 0.4613127     36          1         123 #> 156   cost:type    effect.power 0.5512069     36          1         123 #> 157   size:type    effect.power 0.7469902     36          1         123 #> 158 (Intercept) parameter.power 0.7964338     36          1         123 #> 159        cost parameter.power 0.7627026     36          1         123 #> 160       size1 parameter.power 0.4964549     36          1         123 #> 161       size2 parameter.power 0.4964549     36          1         123 #> 162       type1 parameter.power 0.3655058     36          1         123 #> 163       type2 parameter.power 0.3575345     36          1         123 #> 164       type3 parameter.power 0.3655058     36          1         123 #> 165  cost:size1 parameter.power 0.4733657     36          1         123 #> 166  cost:size2 parameter.power 0.4733657     36          1         123 #> 167  cost:type1 parameter.power 0.3397409     36          1         123 #> 168  cost:type2 parameter.power 0.3397409     36          1         123 #> 169  cost:type3 parameter.power 0.3397409     36          1         123 #> 170 size1:type1 parameter.power 0.1988701     36          1         123 #> 171 size2:type1 parameter.power 0.2049134     36          1         123 #> 172 size1:type2 parameter.power 0.2008327     36          1         123 #> 173 size2:type2 parameter.power 0.2028465     36          1         123 #> 174 size1:type3 parameter.power 0.2049134     36          1         123 #> 175 size2:type3 parameter.power 0.1988701     36          1         123 #> 176 (Intercept)    effect.power 0.7852947     37          1         123 #> 177        cost    effect.power 0.7790389     37          1         123 #> 178        size    effect.power 0.5006448     37          1         123 #> 179        type    effect.power 0.5849562     37          1         123 #> 180   cost:size    effect.power 0.4648473     37          1         123 #> 181   cost:type    effect.power 0.5733489     37          1         123 #> 182   size:type    effect.power 0.7687754     37          1         123 #> 183 (Intercept) parameter.power 0.7852947     37          1         123 #> 184        cost parameter.power 0.7790389     37          1         123 #> 185       size1 parameter.power 0.5095474     37          1         123 #> 186       size2 parameter.power 0.5200584     37          1         123 #> 187       type1 parameter.power 0.3460287     37          1         123 #> 188       type2 parameter.power 0.3460287     37          1         123 #> 189       type3 parameter.power 0.3628078     37          1         123 #> 190  cost:size1 parameter.power 0.4819740     37          1         123 #> 191  cost:size2 parameter.power 0.4819740     37          1         123 #> 192  cost:type1 parameter.power 0.3445838     37          1         123 #> 193  cost:type2 parameter.power 0.3445838     37          1         123 #> 194  cost:type3 parameter.power 0.3445838     37          1         123 #> 195 size1:type1 parameter.power 0.2020064     37          1         123 #> 196 size2:type1 parameter.power 0.2063288     37          1         123 #> 197 size1:type2 parameter.power 0.2094348     37          1         123 #> 198 size2:type2 parameter.power 0.2076826     37          1         123 #> 199 size1:type3 parameter.power 0.2012961     37          1         123 #> 200 size2:type3 parameter.power 0.2067776     37          1         123 #> 201 (Intercept)    effect.power 0.8175931     38          1         123 #> 202        cost    effect.power 0.7962184     38          1         123 #> 203        size    effect.power 0.4993165     38          1         123 #> 204        type    effect.power 0.6185299     38          1         123 #> 205   cost:size    effect.power 0.4893051     38          1         123 #> 206   cost:type    effect.power 0.5947261     38          1         123 #> 207   size:type    effect.power 0.8156383     38          1         123 #> 208 (Intercept) parameter.power 0.8175931     38          1         123 #> 209        cost parameter.power 0.7962184     38          1         123 #> 210       size1 parameter.power 0.5131751     38          1         123 #> 211       size2 parameter.power 0.5140269     38          1         123 #> 212       type1 parameter.power 0.3590781     38          1         123 #> 213       type2 parameter.power 0.3730207     38          1         123 #> 214       type3 parameter.power 0.3956758     38          1         123 #> 215  cost:size1 parameter.power 0.4910267     38          1         123 #> 216  cost:size2 parameter.power 0.5103905     38          1         123 #> 217  cost:type1 parameter.power 0.3495862     38          1         123 #> 218  cost:type2 parameter.power 0.3495862     38          1         123 #> 219  cost:type3 parameter.power 0.3773299     38          1         123 #> 220 size1:type1 parameter.power 0.2015990     38          1         123 #> 221 size2:type1 parameter.power 0.2011486     38          1         123 #> 222 size1:type2 parameter.power 0.2095112     38          1         123 #> 223 size2:type2 parameter.power 0.2013861     38          1         123 #> 224 size1:type3 parameter.power 0.2121892     38          1         123 #> 225 size2:type3 parameter.power 0.2097445     38          1         123 #> 226 (Intercept)    effect.power 0.8187401     39          1         123 #> 227        cost    effect.power 0.8143658     39          1         123 #> 228        size    effect.power 0.5398129     39          1         123 #> 229        type    effect.power 0.6225871     39          1         123 #> 230   cost:size    effect.power 0.5131909     39          1         123 #> 231   cost:type    effect.power 0.6153382     39          1         123 #> 232   size:type    effect.power 0.8380883     39          1         123 #> 233 (Intercept) parameter.power 0.8187401     39          1         123 #> 234        cost parameter.power 0.8143658     39          1         123 #> 235       size1 parameter.power 0.5387913     39          1         123 #> 236       size2 parameter.power 0.5474098     39          1         123 #> 237       type1 parameter.power 0.3558576     39          1         123 #> 238       type2 parameter.power 0.3842160     39          1         123 #> 239       type3 parameter.power 0.3842160     39          1         123 #> 240  cost:size1 parameter.power 0.5191018     39          1         123 #> 241  cost:size2 parameter.power 0.5191018     39          1         123 #> 242  cost:type1 parameter.power 0.3548121     39          1         123 #> 243  cost:type2 parameter.power 0.3822490     39          1         123 #> 244  cost:type3 parameter.power 0.3822490     39          1         123 #> 245 size1:type1 parameter.power 0.2145179     39          1         123 #> 246 size2:type1 parameter.power 0.2151937     39          1         123 #> 247 size1:type2 parameter.power 0.2358854     39          1         123 #> 248 size2:type2 parameter.power 0.2201143     39          1         123 #> 249 size1:type3 parameter.power 0.2129932     39          1         123 #> 250 size2:type3 parameter.power 0.2145500     39          1         123 #> 251 (Intercept)    effect.power 0.8309356     40          1         123 #> 252        cost    effect.power 0.8303912     40          1         123 #> 253        size    effect.power 0.5461875     40          1         123 #> 254        type    effect.power 0.6403903     40          1         123 #> 255   cost:size    effect.power 0.5160100     40          1         123 #> 256   cost:type    effect.power 0.6390699     40          1         123 #> 257   size:type    effect.power 0.8390432     40          1         123 #> 258 (Intercept) parameter.power 0.8309356     40          1         123 #> 259        cost parameter.power 0.8303912     40          1         123 #> 260       size1 parameter.power 0.5478595     40          1         123 #> 261       size2 parameter.power 0.5521027     40          1         123 #> 262       type1 parameter.power 0.3916939     40          1         123 #> 263       type2 parameter.power 0.3846057     40          1         123 #> 264       type3 parameter.power 0.4018997     40          1         123 #> 265  cost:size1 parameter.power 0.5269844     40          1         123 #> 266  cost:size2 parameter.power 0.5269844     40          1         123 #> 267  cost:type1 parameter.power 0.3900963     40          1         123 #> 268  cost:type2 parameter.power 0.3900963     40          1         123 #> 269  cost:type3 parameter.power 0.3866960     40          1         123 #> 270 size1:type1 parameter.power 0.2186679     40          1         123 #> 271 size2:type1 parameter.power 0.2168117     40          1         123 #> 272 size1:type2 parameter.power 0.2171821     40          1         123 #> 273 size2:type2 parameter.power 0.2201919     40          1         123 #> 274 size1:type3 parameter.power 0.2152208     40          1         123 #> 275 size2:type3 parameter.power 0.2407802     40          1         123 #> No errors or warnings encountered during power curve generation!"},{"path":"https://tylermorganwall.github.io/skpr/reference/priorlevels.html","id":null,"dir":"Reference","previous_headings":"","what":"Prior levels — priorlevels","title":"Prior levels — priorlevels","text":"Returns number levels prior parameter","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/priorlevels.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prior levels — priorlevels","text":"","code":"priorlevels(levelvector)"},{"path":"https://tylermorganwall.github.io/skpr/reference/priorlevels.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Prior levels — priorlevels","text":"Returns vector consisting number levels preceeding parameter (including intercept)","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/quad.html","id":null,"dir":"Reference","previous_headings":"","what":"quadratic — quad","title":"quadratic — quad","text":"quadratic","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/quad.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"quadratic — quad","text":"","code":"quad(formula)"},{"path":"https://tylermorganwall.github.io/skpr/reference/quad.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"quadratic — quad","text":"formula formula expanded","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/quad.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"quadratic — quad","text":"Returns quadratic model formula","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/rearrange_formula_by_order.html","id":null,"dir":"Reference","previous_headings":"","what":"Rearrange formula by order — rearrange_formula_by_order","title":"Rearrange formula by order — rearrange_formula_by_order","text":"Rearrange higher order arithmatic terms end formula","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/rearrange_formula_by_order.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Rearrange formula by order — rearrange_formula_by_order","text":"","code":"rearrange_formula_by_order(model, data)"},{"path":"https://tylermorganwall.github.io/skpr/reference/rearrange_formula_by_order.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Rearrange formula by order — rearrange_formula_by_order","text":"model Base model","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/rearrange_formula_by_order.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Rearrange formula by order — rearrange_formula_by_order","text":"Rearranged model","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/reduceRunMatrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Remove columns not in model — reduceRunMatrix","title":"Remove columns not in model — reduceRunMatrix","text":"Remove columns model","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/reduceRunMatrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Remove columns not in model — reduceRunMatrix","text":"","code":"reduceRunMatrix(RunMatrix, model, first_run = TRUE)"},{"path":"https://tylermorganwall.github.io/skpr/reference/reduceRunMatrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Remove columns not in model — reduceRunMatrix","text":"reduced model matrix.","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/remove_skpr_blockcols.html","id":null,"dir":"Reference","previous_headings":"","what":"Remove skpr-generated blocking columns — remove_skpr_blockcols","title":"Remove skpr-generated blocking columns — remove_skpr_blockcols","text":"Remove skpr-generated REML blocking columns present","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/remove_skpr_blockcols.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Remove skpr-generated blocking columns — remove_skpr_blockcols","text":"","code":"remove_skpr_blockcols(RunMatrix)"},{"path":"https://tylermorganwall.github.io/skpr/reference/remove_skpr_blockcols.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Remove skpr-generated blocking columns — remove_skpr_blockcols","text":"RunMatrix run matrix","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/remove_skpr_blockcols.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Remove skpr-generated blocking columns — remove_skpr_blockcols","text":"Run Matrix","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/run_documentation.html","id":null,"dir":"Reference","previous_headings":"","what":"Run Documentation — run_documentation","title":"Run Documentation — run_documentation","text":"Run Documentation","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/run_documentation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run Documentation — run_documentation","text":"","code":"run_documentation()"},{"path":"https://tylermorganwall.github.io/skpr/reference/run_documentation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Run Documentation — run_documentation","text":"bool","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/set_up_progressr_handler.html","id":null,"dir":"Reference","previous_headings":"","what":"Set up progressr handler — set_up_progressr_handler","title":"Set up progressr handler — set_up_progressr_handler","text":"Set progressr handler","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/set_up_progressr_handler.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set up progressr handler — set_up_progressr_handler","text":"","code":"set_up_progressr_handler(msg_string, type_string)"},{"path":"https://tylermorganwall.github.io/skpr/reference/skprGUI.html","id":null,"dir":"Reference","previous_headings":"","what":"Graphical User Interface for skpr — skprGUI","title":"Graphical User Interface for skpr — skprGUI","text":"skprGUI provides graphical user interface skpr, within R Studio.","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/skprGUI.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Graphical User Interface for skpr — skprGUI","text":"","code":"skprGUI(   browser = FALSE,   return_app = FALSE,   multiuser = FALSE,   progress = TRUE )"},{"path":"https://tylermorganwall.github.io/skpr/reference/skprGUI.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Graphical User Interface for skpr — skprGUI","text":"browser Default `FALSE`. Whether open application external browser. return_app Default `FALSE`. `TRUE`, return shinyApp object. multiuser Default `FALSE`. `TRUE`, turn disable multicore functionality enable non-blocking operation. progress Default `TRUE`. Whether include progress bar application. Note: `multiuser = TRUE`, progress bars turned default.","code":""},{"path":"https://tylermorganwall.github.io/skpr/reference/skprGUI.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Graphical User Interface for skpr — skprGUI","text":"","code":"#Type `skprGUI()` to begin"}]
