library(lme4)

context("Run Examples")

test_that("gen_design example code runs without errors", {
  #'#Generating a basic 2 factor design:
  basicdesign <- expand.grid(x1=c(-1,1), x2=c(-1,1))
  #'
  #'#This factorial design is used as an input in the optimal design generation for a
  #'#D-optimal design with 11 runs.
  expect_silent({design <- gen_design(factorial=basicdesign, model=~x1+x2, trials=11)})
  #'
  #'#We can also use the dot operator to automatically use all of the terms in the model:
  expect_silent({design <- gen_design(factorial=basicdesign, model=~., trials=11)})
  #'
  #'#Here we add categorical factors, specified by using "as.factor" in expand.grid:
  expect_silent({
    categoricaldesign <- expand.grid(a=c(-1,1), b=as.factor(c("A","B")), c=as.factor(c("High","Med","Low")))})
  #'
  #'#This factorial design is used as an input in the optimal design generation.
  expect_silent({
    design2 = gen_design(factorial=categoricaldesign, model=~a+b+c, trials=19)})
  #'
  #'#We can also increase the number of times the algorithm repeats the search to increase the probability
  #'#that the globally optimal design was found.
  expect_silent({
    design2 = gen_design(factorial=categoricaldesign, model=~a+b+c, trials=19, repeats=100)})
  #'
  #'#You can also use a higher order model when generating the design:
  expect_silent({
    design2 = gen_design(factorial=categoricaldesign, model=~a+b+c+a*b*c, trials=12)
    })
  #'
  #'#To evaluate a response surface design, include center points in the candidate set and do not include
  #'#quadratic effects with categorical factors.
  #'
  expect_silent({
    designquad = expand.grid(a=c(1,0,-1), b=c(-1,0,1), c=c("A","B","C"))})
  #'
  expect_silent({
    gen_design(designquad, ~a+b+I(a^2)+I(b^2)+a*b*c, 20)})
  #'
  #'#The optimality criterion can also be changed:
  expect_silent({gen_design(designquad, ~a+b+I(a^2)+I(b^2)+a*b*c, 20,optimality="I")})
  expect_silent({gen_design(designquad, ~a+b+I(a^2)+I(b^2)+a*b*c, 20,optimality="A")})
  #'
  #'#A split-plot design can be generated by first generating an optimal blocking design using the
  #'#hard-to-change factors and then using that as the input for the split-plots design.
  #'#This generates an optimal subplot design that accounts for the existing split-plot settings.
  #'#See the accompannying paper "___________" for details of the implementation.
  #'
  hardtochangefactor = expand.grid(Altitude=c(-1,1))
  expect_silent({hardtochangedesign = gen_design(factorial = hardtochangefactor, model=~Altitude, trials=11)})
  #'
  #'#Now we can use the D-optimal blocked design as an input to our full design.
  #'
  easytochangefactors = expand.grid(Range=as.factor(c("Close","Medium","Far")), Power=c(1,-1))
  #'
  #'#Here, we specify the easy to change factors for the factorial design, and input the hard-to-change design
  #'#along with a vector listing the number of repetitions within each block for the blocked design. There should be
  #'#a size entry for every block and the number of runs specified in the trials argument needs to equal the
  #'#sum of all of the block sizes or else the program will throw an error.
  #'
  #'#Since we have 11 runs in our hard-to-change design, we need a vector specifying the size of each 11 runs. Here
  #'#we specify the blocks be three runs each (meaning the final design will be 33 runs):
  #'
  #'splitplotblocksize = rep(3,11)
  #'
  #'#Putting this all together:
  expect_silent({
    designsplitplot = gen_design(easytochangefactors, ~Range+Power, trials=33, htc=hardtochangedesign,
                                 blocksizes = splitplotblocksize)})
  #'
  #'#The split-plot structure is encoded into the row names, with a period demarcating the blocking level. This process
  #'#can be repeated for arbitrary levels of blocking (i.e. a split-plot design can be entered in as the hard-to-change
  #'#to produce a split-split-plot design, which can be passed as another hard-to-change design to produce a
  #'#split-split-split plot design, etc).
  #'
  extremelyhtcfactors = expand.grid(Location=as.character(c("East","West")))
  veryhtcfactors = expand.grid(Climate = as.factor(c("Dry","Wet","Arid")))
  htcfactors = expand.grid(Vineyard = as.factor(c("A","B","C","D")))
  etcfactors = expand.grid(Age = c(1,-1))
  #'
  expect_silent(gen_design(extremelyhtcfactors, ~Location, trials=6) -> temp)
  expect_silent(gen_design(veryhtcfactors, ~Climate, trials=12, splitplotdesign = temp, splitplotsizes=rep(2,6)) -> temp)
  expect_silent(gen_design(htcfactors, ~Vineyard, 48, splitplotdesign = temp, splitplotsizes = rep(4,12)) -> temp)
  expect_silent(gen_design(etcfactors, ~Age, 192, splitplotdesign = temp, splitplotsizes = rep(4,48)) -> splitsplitsplitplotdesign)
  #'
  #'#A design's diagnostics can be accessed via the following attributes:
  #'
  expect_silent(attr(design,"D")) #D-Efficiency
  expect_silent(attr(design,"A")) #A-Efficiency
  expect_silent(attr(design,"I")) #The average prediction variance across the design space
  #'
  #'#The correlation matrix can be accessed via the "correlation.matrix" attribute:
  #'
  expect_silent({correlation.matrix = attr(design2, "correlation.matrix")})
  #'
  #'#A correlation color map can be produced with the following call to ggplot2 and reshape2
  #'


})


test_that("eval_design example code runs without errors", {
  #'@examples #Generating a simple 2x3 factorial using AlgDesign's gen.factorial function
  #'#to feed into our optimal design generation and generating a 11-run design.
  factorial <- AlgDesign::gen.factorial(levels = 2, nVars = 3, varNames = c("A", "B", "C"))
  #'#this can also be generated with expand.grid as:
  factorial <- expand.grid(A=c(1,-1),B=c(1,-1),C=c(1,-1))
  expect_silent({optdesign = gen_design(factorial=factorial, model= ~A+B+C,trials=11,optimality="D",repeats=100)})
  #'
  #'#Now evaluating that design (with default anticipated coefficients and a delta of 2):
  expect_silent(eval_design(RunMatrix=optdesign, model= ~A+B+C, alpha=0.2))
  #'
  #'#Evaluating a subset of the design (changing the power due to a different number of
  #'#degrees of freedom)
  expect_silent(eval_design(RunMatrix=optdesign, model= ~A+C, alpha=0.2))
  #'
  #'#Halving the signal-to-noise ratio by setting a different delta (default is 2):
  expect_silent(eval_design(RunMatrix=optdesign, model= ~A+B+C, alpha=0.2,delta=1))
  #'
  #'#With 3+ level categorical factors, the choice of anticipated coefficients directly changes the
  #'#final power calculation. For the most conservative power calculation, that involves
  #'#setting all anticipated coefficients in a factor to zero except for one. We can specify this
  #'#option with the "conservative" argument.
  #'
  expect_silent({factorialcoffee = expand.grid(cost=c(1,2),
                                type=as.factor(c("Kona","Colombian","Ethiopian","Sumatra")),
                                size=as.factor(c("Short","Grande","Venti")))})
  #'
  expect_silent({designcoffee = gen_design(factorialcoffee,~cost + size + type,trials=29,optimality="D",repeats=100)})
  #'
  #'#Evaluate the design, with default anticipated coefficients (conservative is FALSE by default).
  expect_silent(eval_design(designcoffee,model=~cost+size+type, alpha=0.05))
  #'
  #'#Evaluate the design, with conservative anticipated coefficients:
  expect_silent(eval_design(designcoffee,model=~cost+size+type, alpha=0.05,conservative=TRUE))
  #'
  #'#which is the same as the following, but now explicitly entering the coefficients:
  expect_silent(eval_design(designcoffee,model=~cost+size+type, alpha=0.05,anticoef=c(1,1,1,0,0,1,0)))
  #'
  #'#If the first level in a factor is not the one that you want to set to one
  #'#in the conservative calculation, enter the anticipated coefficients in manually.
  expect_silent(eval_design(designcoffee,model=~cost+size+type, alpha=0.05,anticoef=c(1,1,0,0,1,0,1)))
  #'
  #'#You can also evaluate the design with higher order effects:
  expect_silent(eval_design(designcoffee,model=~cost+size+type+cost*type, alpha=0.05))
  #'
  #'#Blocked designs can also be evaluated by specifying the blocking model.
  #'
  #'#Generating blocked design
  coffeeblocks = expand.grid(caffeine=c(1,-1))
  expect_silent({coffeeblockdesign = gen_design(coffeeblocks, ~caffeine, trials=12)})
  expect_silent({coffeefinaldesign = gen_design(factorialcoffee, model=~cost+size+type,trials=36,
                                 wholeblock=coffeeblockdesign, blocksize=3)})
  #'
  #'#Evaluating design
  expect_silent(eval_design(coffeefinaldesign, ~cost+size+type + caffeine, 0.2, blockmodel= ~caffeine))
  #'
  #'#We can also evaluate the design with a custom ratio between the whole plot error to
  #'#the run-to-run error.
  expect_silent(eval_design(coffeefinaldesign, ~cost+size+type + caffeine, 0.2, blockmodel= ~caffeine,
              varianceratio=2))
})


test_that("eval_design_mc example code runs without errors", {
  #'@examples #We first generate a full factorial design using expand.grid:
  factorialcoffee = expand.grid(cost=c(-1, 1),
                                type=as.factor(c("Kona", "Colombian", "Ethiopian", "Sumatra")),
                                size=as.factor(c("Short", "Grande", "Venti")))
  #'
  #'#And then generate the 21-run D-optimal design using gen_design.
  #'
  expect_silent(designcoffee <- gen_design(factorialcoffee, model=~cost + type + size, trials=21, optimality="D"))
  #'
  #'#To evaluate this design using a normal approximation, we just use eval_design
  #'#(here using the default settings for contrasts, delta, and the anticipated coefficients):
  #'
  expect_silent(eval_design(RunMatrix=designcoffee, model=~cost + type + size, 0.05))
  #'
  #'#We want to evaluate this design with a Monte Carlo approach. In this case, we need
  #'#to create a function that generates random numbers based on our run matrix X and
  #'#our anticipated coefficients (b).
  #'
  rgen = function(X, b, delta) {
    return(rnorm(n=nrow(X), mean = X %*% b + delta, sd = 1))
  }
  #'
  #'#Here we generate our nrow(X) random numbers from a population with a mean that varies depending
  #'#on the design (and is set by multiplying the run matrix X with the anticipated coefficients
  #'#vector b), and has a standard deviation of one. To evaluate this, we enter the same information
  #'#used in eval_design, with the addition of the number of simulations "nsim", the distribution
  #'#family used in fitting for the glm "glmfamily", the custom random generation function "rfunction",
  #'#and whether or not we want the computation to be done with all the cores available "parallel".
  #'
  expect_silent(eval_design_mc(RunMatrix=designcoffee, model=~cost + type + size, alpha=0.05,
                 nsim=100, glmfamily="gaussian", rfunction=rgen))
  #'
  #'#We see here we generate approximately the same parameter powers as we do
  #'#using the normal approximation in eval_design. Like eval_design, we can also change
  #'#delta to produce a different signal-to-noise ratio:
  #'
  expect_silent(eval_design_mc(RunMatrix=designcoffee, model=~cost + type + size, alpha=0.05,
                 nsim=100, glmfamily="gaussian", rfunction=rgen, delta=1))
  #'
  #'#However, we could also specify this using a different random generator function by
  #'#doubling the standard deviation of the population we are drawing from:
  #'
  rgensnr = function(X, b, delta) {
    return(rnorm(n=nrow(X), mean = X %*% b + delta, sd = 2))
  }
  #'
  expect_silent(eval_design_mc(RunMatrix=designcoffee, model=~cost + type + size, alpha=0.05,
                 nsim=100, glmfamily="gaussian", rfunction=rgensnr))
  #'
  #'#Both methods provide the same end result.
  #'
  #'#Like eval_design, we can also evaluate the design with a different model than
  #'#the one that generated the design.
  expect_silent(eval_design_mc(RunMatrix=designcoffee, model=~cost + type, alpha=0.05,
                 nsim=100, glmfamily="gaussian", rfunction=rgen))
  #'
  #'#Here we evaluate the design using conservative anticipated coefficients:
  expect_silent(eval_design_mc(RunMatrix=designcoffee, model=~cost + type + size, 0.05,
                 nsim=100, glmfamily="gaussian", rfunction=rgen, conservative=TRUE))
  #'
  #'#And here it is evaluated with higher order effects included:
  expect_silent(eval_design_mc(RunMatrix=designcoffee,model=~cost + type + size + cost*type, 0.05,
                 nsim=100,glmfamily="gaussian",rfunction=rgen))
  #'
  #'#We can also set "parallel=TRUE" to turn use all the cores available to speed up
  #'#computation.
  #'\dontrun{eval_design_mc(RunMatrix=designcoffee,model=~cost + type + size, 0.05,
  #'               nsim=100,glmfamily="gaussian",rfunction=rgen,parallel=TRUE)}
  #'
  #'#We can also evaluate split-plot designs. First, let us generate the split-plot design:
  #'
  vhtc = expand.grid(Store=as.factor(c("A","B")))
  htc = expand.grid(Temp = c(1,-1))
  #'
  vhtcdesign = gen_design(factorial=vhtc, model=~Store, trials=6)
  htcdesign = gen_design(factorial=htc, model=~Temp, trials=18, splitplotdesign=vhtcdesign, splitplotsizes=rep(3,6))
  expect_silent(splitplotdesign <- gen_design(factorial=factorialcoffee, model=~cost+type+size+size, trials=54,
                               splitplotdesign=htcdesign, splitplotsizes=rep(3,18)))
  #'
  #'#Each block has an additional noise term associated with it in addition to the normal error term.
  #'#This is specified by an additional random generating function and a vector specifying the input for
  #'#each split-plot level. This function is stating that there is an addition gaussian noise term with each
  #'#block, and the vector is stating it has a standard deviation of one for each level. This is equivalent to
  #'#a variance ratio of one between the whole plots and the sub-plots.
  #'#See the accompanying paper _____ for further technical details.
  #'
  blockvector = c(1,1)
  #'
  #'#Evaluate the design. Note the decreased power for the blocking factors. If
  expect_silent(eval_design_mc(RunMatrix=splitplotdesign, model=~Store+Temp+cost+type+size, alpha=0.05,
                 nsim=100, glmfamily="gaussian", rfunction=rgen, blocknoise = blockvector))
  #'
  #'#We can also use this method to evaluate designs that cannot be easily
  #'#evaluated using normal approximations. Here, we evaluate a design and see
  #'#if we can detect the difference between each factor changing whether an event
  #'#70% of the time or 90% of the time.
  #'
  factorialbinom = expand.grid(a=c(-1,1),b=c(-1,1))
  expect_silent(designbinom <- gen_design(factorialbinom,model=~a+b,trials=90,optimality="D",repeats=100))
  #'
  #'#Here our random binomial generator simulates a response based on the resulting
  #'#probability from of all the columns in one row influencing the result.
  #'
  rgenbinom = function(X, b, delta) {
    rbinom(n=nrow(X), size=1, prob = 1 / ( 1 + exp(-(X %*% b - delta))))
  }
  #'
  #'#Plugging everything in, we now evaluate our model and obtain the binomial power.
  #'#(the anticipated coefficients were determined empircally to set the
  #'#high and low probabilities correctly for each factor)
  #'
  expect_silent(eval_design_mc(designbinom,~a+b,alpha=0.2,nsim=100,anticoef=c(1.5,0.7,0.7),
                 glmfamily="binomial",rfunction=rgenbinom))
  #'
  #'#We can also use this method to determine power for poisson response variables.
  #'#We design our test to detect if each factor changes the base rate of 0.2 by
  #'#a factor of 2. We generate the design:
  #'
  factorialpois = expand.grid(a=as.numeric(c(-1,0,1)),b=c(-1,0,1))
  expect_silent(designpois <- gen_design(factorialpois,~a+b,trials=90,optimality="D",repeats=100))
  #'
  #'
  #'#Here we return a random poisson number of events that vary depending
  #'#on the rate in the design.
  rrate = function(X, b, delta) {
    return(rpois(n=nrow(X), lambda=exp(X %*% b + delta)))
  }
  expect_silent(eval_design_mc(designpois,~a+b,0.2,nsim=100,glmfamily="poisson",rfunction=rrate,
                 anticoef=c(log(0.2),log(2),log(2))))
  #'#where the anticipated coefficients are chosen to set the base rate at 0.2
  #'#(from the intercept) as well as how each factor changes the rate (a factor of 2, so log(2)).
  #'#We see here we need about 90 test events to get accurately distinguish the three different
  #'#rates in each factor to 90% power.
})


test_that("eval_design_survival_mc example code runs without errors", {
  #'@examples #These examples focus on the survival analysis case and assume familiarity
  #'#with the basic functionality of eval_design_mc.
  #'
  #'#We first generate simple 2-level design using expand.grid:
  basicdesign = expand.grid(a=c(-1,1))
  expect_silent(design <- gen_design(factorial=basicdesign,model=~a,trials=100,
                            optimality="D",repeats=100))
  #'
  #'#We want to evaluate this design with a Monte Carlo approach, taking into account
  #'#that some of the points will be censored. In this case, we need
  #'#to create a function that generates random numbers based on our run matrix X and
  #'#our anticipated coefficients (b), censors the results from those numbers based
  #'#on the censoring criteria, and then returns a Surv object from the survival package.
  #'#For an exponential distribution, the censored response is generated according to the
  #'#following formula:
  #'
  rsurvival = function(X,b) {
    Y = rexp(n=nrow(X),rate=exp(-(X %*% b)))
    censored = Y > 1
    Y[censored] = 1
    return(Surv(time=Y,event=!censored,type="right"))
  }
  #'
  #'#We can then evaluate the power of the design in the same way as eval_design_mc:
  #'
  expect_silent(eval_design_survival_mc(RunMatrix=design,model=~a,alpha=0.05,nsim=100,
                          distribution="exponential",rfunctionsurv=rsurvival, delta=1))
  #'
  #'#We can also evaluate different censored distributions by specifying a different
  #'#random generating function and changing the distribution argument. You can also
  #'#specify any additional arguments at the end of the function call and they will be
  #'#input into the survreg function when it evaluates.
  #'
  rlognorm = function(X,b) {
    Y = rlnorm(n=nrow(X), meanlog = X %*% b, sdlog = 0.4)
    censored = Y > 1.2
    Y[censored] = 1.2
    return(Surv(time=Y,event=!censored,type="right"))
  }
  #'
  #'#The argument "scale" was not specified in eval_design_survival_mc, but it was passed into
  #'#the survreg function call.
  #'
  expect_silent(eval_design_survival_mc(RunMatrix=design,model=~a,alpha=0.2,nsim=100,
                          distribution="lognormal",rfunctionsurv=rlognorm,
                          anticoef=c(0.184,0.101),delta=2,scale=0.4))
})

test_that("eval_design_custom_mc example code runs without errors", {
  #'@examples #To demonstrate how a user can use their own libraries for Monte Carlo power generation,
  #'#We will recreate eval_design_survival_mc using the eval_design_custom_mc framework.
  #'
  #'#To begin, first let us generate the same design and random generation function shown in the
  #'#eval_design_survival_mc examples:
  #'
  basicdesign = expand.grid(a=c(-1,1))
  expect_silent(design <- gen_design(factorial=basicdesign,model=~a,trials=100,
                            optimality="D",repeats=100))
  #'
  #'#Random number generating function
  #'
  rsurvival = function(X,b) {
    Y = rexp(n=nrow(X),rate=exp(-(X %*% b)))
    censored = Y > 1
    Y[censored] = 1
    return(Surv(time=Y,event=!censored,type="right"))
  }
  #'
  #'#We now need to tell the package how we want to fit our data,
  #'#given the formula and the model matrix X (and, if needed, the list of contrasts).
  #'#If the contrasts aren't required, "contrastlist" should be set to NULL.
  #'#This should return some type of fit object.
  #'
  fitsurv = function(formula, X, contrastlist=NULL) {
    return(survreg(formula, data=X,dist="exponential"))
  }
  #'
  #'
  #'#We now need to tell the package how to extract the p-values from the fit object returned
  #'#from the fit function. This is how to extract the p-values from the survreg fit object:
  #'
  pvalsurv = function(fit) {
    return(summary(fit)$table[,4])
  }
  #'
  #'#And now we evaluate the design, passing the fitting function and p-value extracting function
  #'#in along with the standard inputs for eval_design_mc.
  #'
  expect_silent(eval_design_custom_mc(RunMatrix=design,model=~a,alpha=0.05,nsim=100,
                        fitfunction=fitsurv, pvalfunction=pvalsurv, rfunction=rsurvival, delta=1))
  #'
  #'#This has the exact same behavior as eval_design_survival_mc.
  #'
  #'#-----Cookbook of extractor functions for various libraries-----#
  #'
  #'#glm:
  #'
  #'#bbmle (mle2):
  #'
  #'
  #'#fit.f = mle2(Y~,data=RunMatrix)
  #'
  #'#pvals = coef(bbmle::summary(fit.f))[,4]
  #'
  #'#aov
  #'
  #'#fit = aov(y ~ A + B + A:B, data=mydataframe)
})
